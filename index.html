<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="re-burn"><meta name="copyright" content="re-burn"><title>re-burn 笔记堆</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.1.0'
} </script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">re-burn</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">8</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">re-burn 笔记堆</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">re-burn 笔记堆</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/12/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/">知识蒸馏</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">日常学习笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/">知识蒸馏</a></span><div class="content"><h2 id="论文链接"><a href="#论文链接" class="headerlink" title="论文链接"></a>论文链接</h2><p><a href="https://link.zhihu.com/?target=https://arxiv.org/pdf/1503.02531.pdf">https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1503.02531.pdf</a></p>
<p>Knowledge Distillation，简称KD，顾名思义，就是将已经训练好的模型包含的知识(”Knowledge”)，蒸馏(“Distill”)提取到另一个模型里面去。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>模型压缩：在深度学习的背景下，为了达到更好的预测，常常会有两种方案：1. 使用过参数化的深度神经网络，这类网络学习能力非常强，因此往往加上一定的正则化策略(如dropout)；2. 集成模型(ensemble)，将许多弱的模型集成起来，往往可以实现较好的预测。这两种方案无疑都有较大的「支出」，需要的计算量和计算资源很大，对部署非常不利。这也就是模型压缩的动机：我们希望有一个规模较小的模型，能达到和大模型一样或相当的结果。当然，从头训练一个小模型，从经验上看是很难达到上述效果的，也许我们能先训练一个大而强的模型，然后将其包含的知识转移给小的模型</p>
<p>Rich Caruana等人在[1]中指出，可以让新模型近似(approximate)原模型(模型即函数)。注意到，在机器学习中，我们常常假定输入到输出有一个潜在的函数关系，这个函数是未知的：从头学习一个新模型就是从<strong>有限的数据</strong>中近似一个<strong>未知的函数</strong>。如果让新模型近似原模型，因为原模型的<strong>函数是已知的</strong>，我们可以使用很多非训练集内的伪数据来训练新模型，这显然要更可行。</p>
<p>这样，原来我们需要让新模型的softmax分布与真实标签匹配，现在只需要让新模型与原模型在给定输入下的softmax分布匹配了。直观来看，后者比前者具有这样一个优势：经过训练后的原模型，其softmax分布包含有一定的知识——真实标签只能告诉我们，某个图像样本是一辆宝马，不是一辆垃圾车，也不是一颗萝卜；而经过训练的softmax可能会告诉我们，它最可能是一辆宝马，不大可能是一辆垃圾车，但绝不可能是一颗萝卜</p>
<h2 id="为什么叫「蒸馏」？"><a href="#为什么叫「蒸馏」？" class="headerlink" title="为什么叫「蒸馏」？"></a>为什么叫「蒸馏」？</h2><p>接续前面的讨论，我们的目标是让新模型与原模型的softmax输出的分布充分接近。直接这样做是有问题的：在一般的softmax函数中，自然指数 $$e$$ 先拉大logits之间的差距，然后作归一化，最终得到的分布是一个arg max的近似 ，其输出是一个接近one-hot的向量，其中一个值很大，其他的都很小。这种情况下，前面说到的「可能是垃圾车，但绝不是萝卜」这种知识的体现是非常有限的。相较类似one-hot这样的硬性输出，我们更希望输出更「软」一些。</p>
<p>一种方法是直接比较logits来避免这个问题。具体地，对于每一条数据，记原模型产生的某个logits是 $$v_i$$ ，新模型产生的logits是  $$z_i$$，我们需要最小化</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B2%7D(z_i-v_i)%5E2%5Ctag%7B1%7D" alt="[公式]"></p>
<p>文献[2]提出了更通用的一种做法。考虑一个广义的softmax函数</p>
<p><img src="https://www.zhihu.com/equation?tex=q_i=%5Cfrac%7B%5Cexp(z_i/T)%7D%7B%5Csum_j%5Cexp(z_j/T)%7D%5Ctag%7B2%7D" alt="[公式]"></p>
<p>其中$$T$$是温度，这是从统计力学中的玻尔兹曼分布中借用的概念。容易证明，当温度 $$T$$趋向于0时，softmax输出将收敛为一个one-hot向量（证明可以参考我之前的文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/79585726">浅谈Softmax函数</a>，将$$\beta$$ 替换为 $$1 / T$$即可)；温度趋$$T$$向于无穷时，softmax的输出则更「软」。因此，在训练新模型的时候，可以使用较高的$$T$$使得softmax产生的分布足够软，这时让新模型（同样温度下）的softmax输出近似原模型；在训练结束以后再使用正常的温度$$T=1$$来预测。具体地，在训练时我们需要最小化两个分布的交叉熵(Cross-entropy)，记新模型利用公式(2)产生的分布是$$q$$，原模型产生的分布是，则我们需要最小化</p>
<p><img src="https://www.zhihu.com/equation?tex=C=-p%5E%5Ctop%5Clog+q%5Ctag%7B3%7D" alt="[公式]"></p>
<p>在化学中，蒸馏是一个有效的分离沸点不同的组分的方法，大致步骤是先升温使低沸点的组分汽化，然后降温冷凝，达到分离出目标物质的目的。在前面提到的这个过程中，<strong>我们先让温度</strong> $$T$$ <strong>升高，然后在测试阶段恢复「低温」，从而将原模型中的知识提取出来，因此将其称为是蒸馏</strong>，实在是妙。</p>
<p>当然，如果转移时使用的是有标签的数据，那么也可以将标签与新模型softmax分布的交叉熵加入到损失函数中去。这里需要将式(3) 乘上一个$$T^2$$，这是为了让损失函数的两项的梯度大致在一个数量级上(参考公式 (9))，实验表明这将大大改善新模型的表现(考虑到加入了更多的监督信号)。</p>
<h2 id="与直接优化logits差异相比"><a href="#与直接优化logits差异相比" class="headerlink" title="与直接优化logits差异相比"></a>与直接优化logits差异相比</h2><p>由公式(2)(3)，对于交叉熵损失来说，其对于新模型的某个logit $$z_i$$ 的梯度是</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D%5Cfrac%7B%5Cpartial+C%7D%7B%5Cpartial+z_i%7D&=%5Cfrac%7B1%7D%7BT%7D(q_i-p_i)%5Ctag%7B4%7D%5C%5C+&=%5Cfrac%7B1%7D%7BT%7D%5Cleft(%5Cfrac%7B%5Cexp(z_i/T)%7D%7B%5Csum_j%5Cexp(z_j/T)%7D-+%5Cfrac%7B%5Cexp(v_i/T)%7D%7B%5Csum_j%5Cexp(v_j/T)%7D%5Cright)%5Ctag%7B5%7D+%5Cend%7Balign%7D" alt="[公式]"></p>
<p>由于$$ e^x-1$$ 与 $$x$$ 是<strong>等价无穷小(</strong>$$x \to 0$$ 时**)**，易知，当$$T$$充分大时，有</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D%5Cfrac%7B%5Cpartial+C%7D%7B%5Cpartial+z_i%7D&%5Capprox%5Cfrac%7B1%7D%7BT%7D%5Cleft(%5Cfrac%7B1+z_i/T%7D%7B%5Csum_j(1+z_j/T)%7D-%5Cfrac%7B1+v_i/T%7D%7B%5Csum_j(1+v_j/T)%7D%5Cright)%5Ctag%7B6%7D%5C%5C+&=%5Cfrac%7B1%7D%7BT%7D%5Cleft(%5Cfrac%7B1+z_i/T%7D%7BN+%5Csum_jz_j/T%7D-%5Cfrac%7B1+v_i/T%7D%7BN+%5Csum_jv_j/T%7D%5Cright)%5Ctag%7B7%7D%5C%5C+%5Cend%7Balign%7D" alt="[公式]"></p>
<p>假设所有logits对每个样本都是零均值化的，即 <img src="https://www.zhihu.com/equation?tex=%5Csum_jz_j=%5Csum_jv_j=0" alt="[公式]"> ，则有</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D%5Cfrac%7B%5Cpartial+C%7D%7B%5Cpartial+z_i%7D&%5Capprox%5Cfrac%7B1%7D%7BT%7D%5Cleft(%5Cfrac%7B1+z_i/T%7D%7BN%7D-%5Cfrac%7B1+v_i/T%7D%7BN%7D%5Cright)%5Ctag%7B8%7D%5C%5C+&=%5Cfrac%7B1%7D%7BNT%5E2%7D%5Cleft(z_i-v_i%5Cright)%5Ctag%7B9%7D+%5Cend%7Balign%7D" alt="[公式]"></p>
<p>所以，如果：1. $$T$$非常大，2. logits对所有样本都是零均值化的，则知识蒸馏和最小化logits的平方差(公式 (1) )是等价的(因为梯度大致是同一个形式)。实验表明，温度 $$T$$ 不能取太大，而应该使用某个适中的值，这表明忽略极负的logits对新模型的表现很有帮助(较低的温度产生的分布比较「硬」，倾向于忽略logits中极小的负值)。</p>
<h2 id="实验与结论"><a href="#实验与结论" class="headerlink" title="实验与结论"></a>实验与结论</h2><p>Hinton等人做了三组实验，其中两组都验证了知识蒸馏方法的有效性。在MNIST数据集上的实验表明，即便有部分类别的样本缺失，新模型也可以表现得很不错，只需要修改相应的偏置项，就可以与原模型表现相当。在语音任务的实验也表明，蒸馏得到的模型比从头训练的模型捕捉了更多数据集中的有效信息，表现仅比集成模型低了0.3个百分点。总体来说知识蒸馏是一个简单而有效的模型压缩&#x2F;训练方法。这大体上是因为原模型的softmax提供了比one-hot标签更多的监督信号[3]。</p>
<p>知识蒸馏在后续也有很多延伸工作。在NLP方面比较有名的有Yoon Kim等人的<a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1606.07947">Sequence-Level Knowledge Distillation</a> 等。总的来说，对一些比较臃肿、不便部署的模型，可以将其「知识」转移到小的模型上。比如，在机器翻译中，一般的模型需要有较大的容量(capacity)才可能获得较好的结果；现在非常流行的BERT及其变种，规模都非常大；更不用提，一些情形下我们需要将这些本身就很大的深度模型集成为一个ensemble，这时候，可以用知识蒸馏压缩出一个较小的、「便宜」的模型。</p>
<p>另外，在多任务的情境下，使用一般的策略训练一个多任务模型，可能达不到比单任务更好的效果，文献[3]探索了使用知识蒸馏，利用单任务的模型来指导训练多任务模型的方法，很值得参考。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>(4)梯度的推导。</p>
<p>由链式法则，有</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+C%7D%7B%5Cpartial+z%7D=%5Cfrac%7B%5Cpartial+q%7D%7B%5Cpartial+z%7D%5Cfrac%7B%5Cpartial+C%7D%7B%5Cpartial+q%7D%5Ctag%7B10%7D" alt="[公式]"></p>
<p>注意到 $$p$$ 是原模型产生的softmax输出，与 $$ z$$ 无关。</p>
<p>后一项 $$\partial C / \partial q $$ 比较容易得到，因为 </p>
<p><img src="https://www.zhihu.com/equation?tex=C=%5Csum_%7Bi=1%7D%5E%7Bn%7D-p_i%5Clog+q_i" alt="[公式]"> </p>
<p>所以</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+C%7D%7B%5Cpartial+q_i%7D=-%5Cfrac%7Bp_i%7D%7Bq_i%7D%5Ctag%7B11%7D" alt="[公式]"></p>
<p>则 $$\partial C / \partial q $$是一个 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 维向量</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+C%7D%7B%5Cpartial+q%7D=%5Cleft%5B%5Cbegin%7Bmatrix%7D+-%5Cfrac%7Bp_1%7D%7Bq_1%7D%5C%5C+-%5Cfrac%7Bp_2%7D%7Bq_2%7D%5C%5C+%5Cvdots%5C%5C+-%5Cfrac%7Bp_n%7D%7Bq_n%7D++%5Cend%7Bmatrix%7D%5Cright%5D%5Ctag%7B12%7D" alt="[公式]"></p>
<p>前一项 $$\partial q / \partial z$$是一个 $$n\times n$$ 的方阵，分类讨论可以得到。参考公式 (2)，记</p>
<p> <img src="https://www.zhihu.com/equation?tex=Z=%5Csum_k+%5Cexp(z_k/T)" alt="[公式]"> </p>
<p>由除法的求导法则，输出元素 $$q_i$$ 对输入 $$z_j$$ 的偏导是</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+q_i%7D%7B%5Cpartial+z_j%7D=%5Cfrac%7B1%7D%7BZ%5E2%7D%5Cleft(Z%5Cfrac%7B%5Cpartial+%5Cexp(z_i/T)%7D%7B%5Cpartial+z_j%7D-%5Cexp(z_i/T)%5Cboxed%7B%5Cfrac%7B%5Cpartial+Z%7D%7B%5Cpartial+z_j%7D%7D++%5Cright)%5Ctag%7B13%7D" alt="[公式]"></p>
<p>注意上面右侧加方框部分，可以进一步展开</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+Z%7D%7B%5Cpartial+z_j%7D=%5Cfrac%7B1%7D%7BT%7D%5Cexp(z_j/T)%5Ctag%7B14%7D" alt="[公式]"></p>
<p>这样，代入公式 <img src="https://www.zhihu.com/equation?tex=(13)" alt="[公式]"> ，并且将括号展开，可以得到</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%5Cfrac%7B%5Cpartial+q_i%7D%7B%5Cpartial+z_j%7D&=%5Cfrac%7B1%7D%7BZ%7D%5Cfrac%7B%5Cpartial+%5Cexp(z_i/T)%7D%7B%5Cpartial+z_j%7D-%5Cfrac%7B1%7D%7BTZ%5E2%7D%5Cexp(z_i/T)%5Cexp(z_j/T)%5Ctag%7B15%7D%5C%5C+&=%5Cfrac%7B1%7D%7BZ%7D%5Cfrac%7B%5Cpartial+%5Cexp(z_i/T)%7D%7B%5Cpartial+z_j%7D-%5Cfrac%7B1%7D%7BT%7D%5Cfrac%7B%5Cexp(z_i/T)%7D%7BZ%7D%5Cfrac%7B%5Cexp(z_j/T)%7D%7BZ%7D%5Ctag%7B16%7D%5C%5C+&=%5Cfrac%7B1%7D%7BZ%7D%5Cboxed%7B%5Cfrac%7B%5Cpartial+%5Cexp(z_i/T)%7D%7B%5Cpartial+z_j%7D%7D-%5Cfrac%7B1%7D%7BT%7Dq_iq_j%5Ctag%7B17%7D%5C%5C+%5Cend%7Balign%7D" alt="[公式]"></p>
<p>左侧方框内偏导可以分类讨论得到</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+%5Cexp(z_i/T)%7D%7B%5Cpartial+z_j%7D=%5Cbegin%7Bcases%7D+%5Cfrac%7B1%7D%7BT%7D%5Cexp(z_i/T),%5C+&%5Ctext%7Bif+%7Di=j%5C%5C+0,&%5Ctext%7Bif+%7Di%5Cneq+j+%5Cend%7Bcases%7D%5Ctag%7B18%7D" alt="[公式]"></p>
<p>带入式 (17)，得到</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%5Cfrac%7B%5Cpartial+q_i%7D%7B%5Cpartial+z_j%7D+&=%5Cbegin%7Bcases%7D+%5Cfrac%7B1%7D%7BT%7D%5Cleft(%5Cfrac%7B%5Cexp(z_i/T)%7D%7BZ%7D-q_iq_j%5Cright)+,%5C+&%5Ctext%7Bif+%7Di=j%5C%5C+-%5Cfrac%7B1%7D%7BT%7Dq_iq_j,&%5Ctext%7Bif+%7Di%5Cneq+j+%5Cend%7Bcases%7D%5Ctag%7B19%7D%5C%5C+&=%5Cbegin%7Bcases%7D+%5Cfrac%7B1%7D%7BT%7D%5Cleft(q_i-q_iq_j%5Cright)+,%5C+&%5Ctext%7Bif+%7Di=j%5C%5C+-%5Cfrac%7B1%7D%7BT%7Dq_iq_j,&%5Ctext%7Bif+%7Di%5Cneq+j+%5Cend%7Bcases%7D%5Ctag%7B20%7D+%5Cend%7Balign%7D" alt="[公式]"></p>
<p>所以 $$\partial q / \partial z$$形式如下</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+q%7D%7B%5Cpartial+z%7D=%5Cfrac%7B1%7D%7BT%7D%5Cleft%5B+%5Cbegin%7Bmatrix%7D+q_1-q_1%5E2+&+-q_1q_2+&+%5Ccdots+&+-q_1q_n%5C%5C+-q_2q_1+&+q_2-q_2%5E2+&+%5Ccdots+&+-q_2q_n%5C%5C+%5Cvdots+&+%5Cvdots+&+%5Cddots+&%5Cvdots%5C%5C+-q_nq_1+&+-q_nq_2+&+%5Ccdots+&+q_n-q_n%5E2+%5Cend%7Bmatrix%7D+%5Cright%5D%5Ctag%7B21%7D" alt="[公式]"></p>
<p>代入式(10)，可得</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D%5Cfrac%7B%5Cpartial+C%7D%7B%5Cpartial+z%7D&=%5Cfrac%7B1%7D%7BT%7D%5Cleft%5B+%5Cbegin%7Bmatrix%7D+q_1-q_1%5E2+&+-q_1q_2+&+%5Ccdots+&+-q_1q_n%5C%5C+-q_2q_1+&+q_2-q_2%5E2+&+%5Ccdots+&+-q_2q_n%5C%5C+%5Cvdots+&+%5Cvdots+&+%5Cddots+&%5Cvdots%5C%5C+-q_nq_1+&+-q_nq_2+&+%5Ccdots+&+q_n-q_n%5E2+%5Cend%7Bmatrix%7D+%5Cright%5D+%5Cleft%5B%5Cbegin%7Bmatrix%7D+-%5Cfrac%7Bp_1%7D%7Bq_1%7D%5C%5C+-%5Cfrac%7Bp_2%7D%7Bq_2%7D%5C%5C+%5Cvdots%5C%5C+-%5Cfrac%7Bp_n%7D%7Bq_n%7D++%5Cend%7Bmatrix%7D%5Cright%5D%5Ctag%7B22%7D%5C%5C++&=%5Cfrac%7B1%7D%7BT%7D%5Cleft%5B%5Cbegin%7Bmatrix%7D+-p_1+%5Csum_kp_kq_1%5C%5C+-p_2+%5Csum_kp_kq_2%5C%5C+%5Cvdots%5C%5C+-p_n+%5Csum_kp_kq_n++%5Cend%7Bmatrix%7D%5Cright%5D%5Ctag%7B23%7D%5C%5C++&=%5Cfrac%7B1%7D%7BT%7D%5Cleft%5B%5Cbegin%7Bmatrix%7D+-p_1+q_1%5C%5C+-p_2+q_2%5C%5C+%5Cvdots%5C%5C+-p_n+q_n+%5Cend%7Bmatrix%7D%5Cright%5D%5Ctag%7B24%7D%5C%5C+&=%5Cfrac%7B1%7D%7BT%7D(q-p)%5Ctag%7B25%7D+%5Cend%7Balign%7D" alt="[公式]"></p>
<p>所以有公式(4) ， <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+C%7D%7B%5Cpartial+z_i%7D=%5Cfrac%7B1%7D%7BT%7D(q_i-p_i)" alt="[公式]"> 。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/12/ViT/">Vision Transformer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">日常学习笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ViT/">ViT</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/transformer/">transformer</a></span><div class="content"><h1 id="Vision-Transformer"><a href="#Vision-Transformer" class="headerlink" title="Vision Transformer"></a>Vision Transformer</h1><p>本文重点介绍ViT原理，同时简单介绍三篇相关论文，这四篇论文的源码见 <a href="https://link.zhihu.com/?target=https://github.com/google-research/vision_transformer">https://github.com/google-research/vision_transformer</a></p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2010.11929">arXiv:2010.11929</a>：An image is worth 16x16 words: Transformers for image recognition at scale（ViT大法，一般人没钱做的工作）</p>
<p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2105.01601">arXiv:2105.01601</a>：MLP-Mixer: An all-MLP Architecture for Vision （用MLPs替代self-attention可以得到和ViT同样好的结果）</p>
<p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.01548">arXiv:2106.01548</a>：When Vision Transformers Outperform ResNets without Pre-training or Strong Data Augmentations （不使用大规模预训练和强数据增强ViT是否依然可以表现优秀）</p>
<p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.10270">arXiv:2106.10270</a>：How to train your ViT? Data, Augmentation, and Regularization in Vision Transformers （通过大量实验，总共训练了超过5w个ViT，教你如何训练自己的ViT模型，以及数据增广和模型正则化什么时候有用）</p>
<p>有关transformer结构和原理，大家可以参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/410258597">Transformer解析</a></p>
<h2 id="arXiv-2010-11929-ViT"><a href="#arXiv-2010-11929-ViT" class="headerlink" title="arXiv:2010.11929 (ViT)"></a>arXiv:2010.11929 (ViT)</h2><p><img src="https://pic2.zhimg.com/80/v2-692d349ee289e1cea9d7d100b6919771_720w.jpg" alt="img"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>ViT是2020年Google团队提出的将Transformer应用在图像分类的模型，虽然不是第一篇将transformer应用在视觉任务的论文，但是因为其模型“简单”且效果好，可扩展性强（scalable，模型越大效果越好），成为了transformer在CV领域应用的里程碑著作，也引爆了后续相关研究</p>
<p>把最重要的说在最前面，ViT原论文中最核心的结论是，当拥有足够多的数据进行预训练的时候，ViT的表现就会超过CNN，突破transformer缺少归纳偏置的限制，可以在下游任务中获得较好的迁移效果</p>
<p>但是当训练数据集不够大的时候，ViT的表现通常比同等大小的ResNets要差一些，因为Transformer和CNN相比缺少归纳偏置（inductive bias），即一种先验知识，提前做好的假设。CNN具有两种归纳偏置，一种是局部性（locality&#x2F;two-dimensional neighborhood structure），即图片上相邻的区域具有相似的特征；一种是平移不变性（translation equivariance）， $$ f(g(x)) = g(f(x)) $$，其中g代表卷积操作，f代表平移操作。当CNN具有以上两种归纳偏置，就有了很多先验信息，需要相对少的数据就可以学习一个比较好的模型</p>
<h3 id="ViT的结构"><a href="#ViT的结构" class="headerlink" title="ViT的结构"></a>ViT的结构</h3><p>ViT将输入图片分为多个patch（16x16），再将每个patch投影为固定长度的向量送入Transformer，后续encoder的操作和原始Transformer中完全相同。但是因为对图片分类，因此在输入序列中加入一个特殊的token，该token对应的输出即为最后的类别预测</p>
<p><img src="https://pic4.zhimg.com/80/v2-5afd38bd10b279f3a572b13cda399233_720w.jpg" alt="img"></p>
<p><em>ViT只使用了Transformer的encoder</em></p>
<p>按照上面的流程图，一个ViT block可以分为以下几个步骤</p>
<p>(1) patch embedding：例如输入图片大小为224x224，将图片分为固定大小的patch，patch大小为16x16，则每张图像会生成224x224&#x2F;16x16&#x3D;196个patch，即输入序列长度为<strong>196</strong>，每个patch维度16x16x3&#x3D;<strong>768</strong>，线性投射层的维度为768xN (N为token的维度，这里N&#x3D;768)，因此输入通过线性投射层之后的维度依然为196x768，即一共有196个token，每个token的维度是768。这里还需要加上一个特殊字符cls，因此最终的维度是<strong>197x768</strong>。到目前为止，已经通过patch embedding将一个视觉问题转化为了一个seq2seq问题</p>
<p>(2) positional encoding（standard learnable 1D position embeddings）：ViT同样需要加入位置编码，位置编码可以理解为一张表，表一共有N行，N的大小和输入序列长度相同，每一行代表一个向量，向量的维度和输入序列embedding的维度相同（768）。注意位置编码的操作是sum，而不是concat。加入位置编码信息之后，维度依然是<strong>197x768</strong></p>
<p>(3) LN&#x2F;multi-head attention&#x2F;LN：LN输出维度依然是197x768。多头自注意力时，先将输入映射到q，k，v，如果只有一个头，qkv的维度都是197x768，如果有12个头（768&#x2F;12&#x3D;64），则qkv的维度是197x64，一共有12组qkv，最后再将12组qkv的输出拼接起来，输出维度是197x768，然后在过一层LN，维度依然是<strong>197x768</strong></p>
<p>(4) MLP：将维度放大再缩小回去，197x768放大为197x3072，再缩小变为<strong>197x768</strong></p>
<p>一个block之后维度依然和输入相同，都是197x768，因此可以堆叠多个block。最后会将特殊字符cls对应的输出$$ z_L^0$$作为encoder的最终输出 ，代表最终的image presentation（另一种做法是不加cls字符，对所有的tokens的输出做一个平均），如下图公式(4)，后面接一个MLP进行图片分类</p>
<p><img src="https://pic2.zhimg.com/80/v2-ebf697b1994598019a6a59855dc0dbed_720w.jpg" alt="img"></p>
<p>其中输入image $$x \in \R^{H \times W \times C}$$，2D patches $$x_p \in \R^{N \times (P^2 \cdot C)}$$ ，$$C$$ 是通道数，$$P$$ 是patch大小，一共有$$N$$个patches， $$N = HW/P^2$$</p>
<p><strong>关于image presentation</strong></p>
<p>是否可以直接使用average pooling得到最终的image presentation，而不加特殊字符cls，通过实验表明，同样可以使用average pooling，原文ViT是为了尽可能是模型结构接近原始的Transformer，所以采用了类似于BERT的做法，加入特殊字符</p>
<p><img src="https://pic1.zhimg.com/80/v2-4a8b39b1d2dd43d1e9b16edbc38b1660_720w.jpg" alt="img"></p>
<p><em>学习率的影响较大，注意调参</em></p>
<p><strong>关于positional encoding</strong></p>
<p>1-D 位置编码：例如3x3共9个patch，patch编码为1到9</p>
<p>2-D 位置编码：patch编码为11,12,13,21,22,23,31,32,33，即同时考虑X和Y轴的信息，每个轴的编码维度是D&#x2F;2</p>
<p>实际实验结果表明，不管使用哪种位置编码方式，模型的精度都很接近，甚至不适用位置编码，模型的性能损失也没有特别大。原因可能是ViT是作用在image patch上的，而不是image pixel，对网络来说这些patch之间的相对位置信息很容易理解，所以使用什么方式的位置编码影像都不大</p>
<p><img src="https://pic1.zhimg.com/80/v2-e152c9ad22f6984912fb0652cf294018_720w.jpg" alt="img"></p>
<p><strong>关于CNN+Transformer</strong></p>
<p>既然CNN具有归纳偏置的特性，Transformer又具有很强全局归纳建模能力，使用CNN+Transformer的混合模型是不是可以得到更好的效果呢？将224x224图片送入CNN得到16x16的特征图，拉成一个向量，长度为196，后续操作和ViT相同</p>
<p><strong>关于输入图片大小</strong></p>
<p>通常在一个很大的数据集上预训练ViT，然后在下游任务相对小的数据集上微调，已有研究表明在分辨率更高的图片上微调比在在分辨率更高的图片上预训练效果更好（It is often beneficial to fine-tune at higher resolution than pre-training）（参考<em>2019-NIPS-Fixing the train test resolution discrepancy</em>）</p>
<p>当输入图片分辨率发生变化，输入序列的长度也发生变化，虽然ViT可以处理任意长度的序列，但是预训练好的位置编码无法再使用（例如原来是3x3，一种9个patch，每个patch的位置编码都是有明确意义的，如果patch数量变多，位置信息就会发生变化），一种做法是使用插值算法，扩大位置编码表。但是如果序列长度变化过大，插值操作会损失模型性能，这是ViT在微调时的一种局限性</p>
<h3 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h3><p><strong>数据集</strong></p>
<p>为了探究模型的可扩展性（to explore model scalability），预训练阶段使用了ImageNet-1K（1.3million）、ImageNet-21K（14million），JFT-18K（303million）三个数据集。同时参考BiT，删除预训练数据集中和下游任务测试集中重复的数据（de-duplicate the pre-training datasets w.r.t. the test sets of the downstream）</p>
<p>下游数据集包括：ImageNet（on the original validation labels），ImageNet （on the cleaned-up ReaL labels ），CIFAR-10&#x2F;100，Oxford-IIIT Pets，Oxford Flowers-102，VTAB (19 tasks)</p>
<p>ImageNet ReaL参考<em>2020-Are we done with imagenet?</em> VTAB参考<em>2019-A large-scale study of representation learning with the visual task adaptation benchmark</em>，所有数据集的预处理参考BiT</p>
<p><strong>模型及变体</strong></p>
<p>（1）ViT：参考BERT，共设置了三种模型变体（增加了Huge变体）如下图所示。例如ViT-L&#x2F;16，代表Large变体，输入patch size为16x16。</p>
<p>（2）CNN：baseline CNNs选择ResNet，同时用Group Normalization替代Batch Normalization，使用standardized convolutions，以提升模型迁移性能。</p>
<p>（3）Hybrid：混合模型就是使用ResNet50输出的特征图，不同stage会得到不同大小的特征图，即生成不同长度序列</p>
<p><img src="https://pic2.zhimg.com/80/v2-54f717f71079becca62a0247660a171d_720w.jpg" alt="img"></p>
<p>Details of Vision Transformer model variants</p>
<p>所有模型的训练均使用Adam（ $$\beta_1=0.99$$ , $$\beta_2=0.999$$），batch_size设为4096，权重衰减（apply a high weight decay of 0.1），同时使用了学习率warmup策略（use a linear learning rate warmup and decay)；微调阶段，使用SGD with momentum，batch_size设为512</p>
<p><strong>实验结果</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-d5e21c0fadf2591220271021f570299d_720w.jpg" alt="img"></p>
<p><em>ViT和其它SOTA模型性能对比，展示了准确率accuraces的均值和标准差，所有结果都是取三轮微调均值的结果（averaged over three fine-tunning runs）。有关ImageNet的实验，在更高分辨率图片上微调(512 for ViT-L&#x2F;16 and 518 for ViT-H&#x2F;14)，同时使用了Polyak averaging(0.9999)</em></p>
<p>可以看到在JFT数据集上预训练的ViT模型，迁移到下游任务后，表现要好于基于ResNet的BiT和基于EfficientNet的Noisy Student，且需要更少的预训练时间</p>
<p><img src="https://pic2.zhimg.com/80/v2-ff04d612cd03446278622d368ec1c6c9_720w.jpg" alt="img"><em>各类模型在VTAB上的表现，ViT同样性能更好</em></p>
<p>上面的实验显示，当在很大的数据集上预训练时，ViT性能超越CNN，后面探究不同大小预训练数据集对模型性能的影响（不能只看超大数据集）</p>
<p><img src="https://pic2.zhimg.com/80/v2-65138c61d2f9c57448b4ba23dad4af55_720w.jpg" alt="img"></p>
<p><em>transfor to ImageNet</em></p>
<p>这里当在更小的数据集上预训练时（ImageNet），优化三个超参数以提升模型性能，分别是weight decay, dropout 和 label smoothing。可以看到当在小数据集上预训练时（ImageNet-1k，1.3million），ViT微调后的效果远远比不上ResNet；在中等数据集上预训练时（ImageNet-21K，14million），两者效果相当；当在很大的数据集上（JFT-300M, 300million）预训练时，ViT的效果要更好。所以当我们只有较小的数据集时，更适合使用ResNet（并不是所有数据集都适合硬套transformer）</p>
<p><img src="https://pic1.zhimg.com/80/v2-719f695ec8fb9c33e19fd8515c1ff230_720w.jpg" alt="img"></p>
<p><em>Linear few-shot evaluation on ImageNet versus pre-training size</em></p>
<p>如上图，在同一个数据集（JFT），分别抽取不同数量的数据（10M，30M，100M，300M），避免不同数据集之间的gap，同时不适用额外的regularization，超参数保证相同。linear evaluation是指直接把预训练模型当做特征提取器，不fine-tune，拿提取到的特征直接做logistic regression。few-shot是指在evaluation的时候，每一类只sample五张图片。</p>
<p>可以看到当数据集很小时，CNN预训练模型表现更好，证明了CNN归纳偏置的有效性，但是当数据集足够大时，归纳偏置和Transformer比较就失去了优势，甚至没有归纳偏置，直接从数据learn patterns会更有效。同时细心观察会发现即使预训练的数据集很大，最后ViT的性能提升也不是很明显，因此如何使用ViT来做这种小样本学习任务，是一个有待继续研究的方向</p>
<p><img src="https://pic4.zhimg.com/80/v2-53da3593bafc05bad3b72099583d909b_720w.jpg" alt="img"><em>Performance versus cost for different architectures: Vision Transformers, ResNets, andhybrids.</em></p>
<p>上图实验证明了ViT的预训练比ResNet要更便宜，即在相同的预训练计算复杂度下，ViT的效果要比ResNet更好。可以看到，当模型较小时，混合模型的表现要更好，但是随着模型的增大，ViT的表现超过了混合模型（为什么混合模型这个时候不如ViT，直觉上混合模型吸收了双方的优点，应该表现更好）。</p>
<h3 id="模型可视化"><a href="#模型可视化" class="headerlink" title="模型可视化"></a>模型可视化</h3><p><img src="https://pic2.zhimg.com/80/v2-fb19c6d629b419b02f26b4db31598a51_720w.jpg" alt="img"></p>
<p><em>ViT block第一层（linear projection)的前28个主成分</em></p>
<p><img src="https://pic2.zhimg.com/80/v2-99f02198921e7aed8162cd7af8a29805_720w.jpg" alt="img"></p>
<p><em>位置编码得相似性分析(cos)，位置越接接近，patches之间的相似度越高；相同行&#x2F;列的patches有相似的embeddings；</em></p>
<p>为了理解self-attention是如何聚合信息的（To understand how ViT uses self-attention to integrate information across the image），基于attention weight计算不同layer不同head的average attention distance</p>
<p><img src="https://pic4.zhimg.com/80/v2-8539fe277eae097183add2d6d2f559e3_720w.jpg" alt="img"></p>
<p><em>每一个layer的每一个head的average attention distance，类似于CNN感受野的概念，可以发现一些head在第一个layer就attent到了几乎整张图片的范围</em></p>
<p>average attention distance，是基于attention weight计算，具体做法是用attention weight乘以query pixel和所有其它pixels的距离，再求平均。原文中是这么表述的——Attention distance was computed for 128 example images by averaging the distance between the query pixel and all other pixels, weighted by the attention weight. Each dot shows the mean attention distance across images for one of 16 heads at one layer. Image width is 224 pixels.</p>
<p><img src="https://pic4.zhimg.com/80/v2-dabb6afe03b02498e0a8081d00c0b437_720w.jpg" alt="img"></p>
<p><em>Representative examples of attention from the output token to the input space.</em></p>
<h2 id="arXiv-2105-01601"><a href="#arXiv-2105-01601" class="headerlink" title="arXiv:2105.01601"></a>arXiv:2105.01601</h2><p><img src="https://pic3.zhimg.com/80/v2-30735a1641e51d73675e69a99dfe0476_720w.jpg" alt="img"></p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>ViT作者团队出品，在CNN和Transformer大火的背景下，舍弃了卷积和注意力机制，提出了MLP-Mixer，一个完全基于MLPs的结构，其MLPs有两种类型，分别是<strong>channel-mixing MLPs</strong>和<strong>token-mixing MLPs</strong>，前者独立作用于image patches（融合通道信息），后者跨image patches作用（融合空间信息）。实验结果表明该结构和SOTA方法同样出色，证明了convolution和attention不是必要操作，如果将其替换为简单的MLP，模型依然可以完美work</p>
<blockquote>
<p>MLP-Mixer contains two types of layers: one with MLPs applied independently to image patches (i.e. “mixing” the per-location features), and one with MLPs applied across patches (i.e. “mixing” spatial information) &#x2F; MLP-Mixer’s architecture is based entirely on multi-layer perceptrons (MLPs) that are repeatedly applied across either spatial locations or feature channels &#x2F; Mixer makes use of two types of MLP layers: channel-mixing MLPs and token-mixing MLPs</p>
</blockquote>
<h3 id="Mixer结构"><a href="#Mixer结构" class="headerlink" title="Mixer结构"></a>Mixer结构</h3><p><img src="https://pic3.zhimg.com/80/v2-ed96c7a5add85b9151c7f10fbda4943a_720w.jpg" alt="img"></p>
<p><em>类似于Transformer，每一个layer输入和输出的维度相同，可以堆叠多个layer</em></p>
<p>类似于ViT，首先进行patch embedding操作，<strong>一个Mixer Layer中包含了channel-mixing MLPs和token-mixing MLPs</strong>，但是Mixer不适用positional encoding，因为token-mixing MLPs对输入tokens的顺序非常敏感</p>
<p><img src="https://pic2.zhimg.com/80/v2-58df6c737fdea377071868f106b7c1c1_720w.jpg" alt="img"></p>
<p>token-mixing MLPs：允许信息在空间维度交互，独立作用于每一个channel，作用于列，融合不同token的特征</p>
<p>channel-mixing MLPs：允许信息在通道交互，独立作用于每一个token，作用于行，融合不同channel的特征</p>
<p>输入image的分辨率为$$H \times W$$，patch的分辨率为$$P \times P$$，则patch的数量$$S = HW/P^2$$，所有的patch拉直后线性投影到维度$$C$$，则得到Mixer Layer的输入$$X \in \R ^{S \times C}$$。token-mixing MLPs作用于$$X$$的列，特征维度不发生变化（$$\R ^S \to \R ^S$$），channel-mixing MLPs作用于$$X$$的行，特征维度同样不发生变化（$$\R ^C \to \R ^C$$）。每一个MLP包含两个全连接层和一个非线性激活（GELU），一个Mixer layers的公式如下，计算复杂度和输入patches的数量成线性关系（ViT是平方关系）</p>
<p><img src="https://pic3.zhimg.com/80/v2-a0abfc39a823b43e061ee5acd14da0e2_720w.jpg" alt="img"></p>
<p>需要注意token-mixing MLPs共享参数，channel-mixing MLPs同样共享参数，因此避免了当输入特征维度增加（$$C$$变大）或者输入序列长度增加（$$S$$变大）时，模型参数量急剧增加的情况，极大减少了内存消耗</p>
<p>模型最后接global average pooling+a linear classifier</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>当在大规模数据集上预训练（100million images），Mixer可以接近CNNs和Transformers的SOTA表现，在ImageNet上达到87.94%的top-1 accuracy；当在更小规模数据集上预训练时（10million），结合一些regularization techniques，Mixer可以接近ViT的性能，但是稍逊于CNN</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/12/transformer/">transformer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">日常学习笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/transformer/">transformer</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></span><div class="content"><h1 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h1><p>谷歌的Transformer模型最早是用于机器翻译任务，当时达到了SOTA效果。Transformer改进了RNN最被人诟病的训练慢的缺点，利用self-attention机制实现快速并行。并且Transformer可以增加到非常深的深度，充分发掘DNN模型的特性，提升模型准确率。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>Attention is All You Need：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a></p>
<h3 id="宏观结构："><a href="#宏观结构：" class="headerlink" title="宏观结构："></a>宏观结构：</h3><p>transformer由编码组件、解码组件和它们之间的连接组成。</p>
<p>编码组件部分由一堆编码器（encoder）构成（论文中是将6个编码器叠在一起——数字6没有什么神奇之处，你也可以尝试其他数字）。解码组件部分也是由相同数量（与编码器对应）的解码器（decoder）组成的。</p>
<p><img src="https://n.sinaimg.cn/front/9/w946h663/20190108/P-K9-hrkkwef7008787.jpg" alt="img"></p>
<p>所有的编码器在结构上都是相同的，但它们没有共享参数。每个编码器都可以分解成两个子层：</p>
<p><img src="https://n.sinaimg.cn/front/719/w1051h468/20190108/X7dZ-hrkkwef7008863.jpg" alt="img"></p>
<p>从编码器输入的句子首先会经过一个自注意力（self-attention）层，这层帮助编码器在对每个单词编码时关注输入句子的其他单词。我们将在稍后的文章中更深入地研究自注意力。</p>
<p>自注意力层的输出会传递到前馈（feed-forward）神经网络中。每个位置的单词对应的前馈神经网络都完全一样（译注：另一种解读就是一层窗口为一个单词的一维卷积神经网络）。</p>
<p>解码器中也有编码器的自注意力（self-attention）层和前馈（feed-forward）层。除此之外，这两个层之间还有一个注意力层，用来关注输入句子的相关部分（和seq2seq模型的注意力作用相似）。</p>
<p><img src="https://n.sinaimg.cn/front/610/w1080h330/20190108/YmrV-hrkkwef7008971.jpg" alt="img"></p>
<h3 id="将张量引入图景"><a href="#将张量引入图景" class="headerlink" title="将张量引入图景"></a>将张量引入图景</h3><p>我们已经了解了模型的主要部分，接下来我们看一下各种向量或张量（译注：张量概念是矢量概念的推广，可以简单理解矢量是一阶张量、矩阵是二阶张量。）是怎样在模型的不同部分中，将输入转化为输出的。</p>
<p>像大部分NLP应用一样，我们首先将每个输入单词通过词嵌入算法转换为词向量。</p>
<p><img src="https://n.sinaimg.cn/sinacn20116/123/w824h99/20190108/f85a-hrkkwef7014602.png" alt="img"></p>
<p>每个单词都被嵌入为512维的向量，我们用这些简单的方框来表示这些向量。</p>
<p>词嵌入过程只发生在最底层的编码器中。所有的编码器都有一个相同的特点，即它们接收一个向量列表，列表中的每个向量大小为512维。在底层（最开始）编码器中它就是词向量，但是在其他编码器中，它就是上一层编码器的输出（也是一个向量列表）。向量列表大小是我们可以设置的超参数——一般是我们训练集中最长句子的长度。</p>
<p>将输入序列进行词嵌入之后，每个单词都会流经编码器中的两个子层。<br><img src="https://n.sinaimg.cn/sinacn20116/71/w1016h655/20190108/a2c2-hrkkwef7014781.jpg" alt="img"></p>
<p>接下来我们看看Transformer的一个核心特性，在这里输入序列中每个位置的单词都有自己独特的路径流入编码器。在自注意力层中，这些路径之间存在依赖关系。而前馈（feed-forward）层没有这些依赖关系。因此在前馈（feed-forward）层时可以并行执行各种路径。</p>
<h3 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h3><p>例如，下列句子是我们想要翻译的输入句子：</p>
<p>The animal didn’t cross the street because it was too tired</p>
<p>这个“it”在这个句子是指什么呢？它指的是street还是这个animal呢？这对于人类来说是一个简单的问题，但是对于算法则不是。</p>
<p>当模型处理这个单词“it”的时候，自注意力机制会允许“it”与“animal”建立联系。</p>
<p>随着模型处理输入序列的每个单词，自注意力会关注整个输入序列的所有单词，帮助模型对本单词更好地进行编码。</p>
<p>首先我们了解一下如何使用向量来计算自注意力，然后来看它实怎样用矩阵来实现。</p>
<p>计算自注意力的第一步就是从每个编码器的输入向量（每个单词的词向量）中生成三个向量。也就是说对于每个单词，我们创造一个查询向量、一个键向量和一个值向量。这三个向量是通过词嵌入与三个权重矩阵后相乘创建的。</p>
<p>可以发现这些新向量在维度上比词嵌入向量更低。他们的维度是64，而词嵌入和编码器的输入&#x2F;输出向量的维度是512. 但实际上不强求维度更小，这只是一种基于架构上的选择，它可以使多头注意力（multiheaded attention）的大部分计算保持不变。</p>
<p><img src="https://n.sinaimg.cn/sinacn20116/96/w1080h616/20190108/5bcc-hrkkwef7014930.jpg" alt="img"></p>
<p>X<del>1</del>与W^Q^权重矩阵相乘得到q1, 就是与这个单词相关的查询向量。以此类推，最终使得输入序列的每个单词的创建一个查询向量、一个键向量和一个值向量。</p>
<p>计算自注意力的第二步是计算得分。假设我们在为这个例子中的第一个词“Thinking”计算自注意力向量，我们需要拿输入句子中的每个单词对“Thinking”打分。这些分数决定了在编码单词“Thinking”的过程中有多重视句子的其它部分。</p>
<p>这些分数是通过打分所有单词的键向量与“Thinking”的查询向量相点积来计算的。所以如果我们是处理位置最靠前的词的自注意力的话，第一个分数是q1和k1的点积，第二个分数是q1和k2的点积。<br><img src="https://n.sinaimg.cn/sinacn20116/697/w970h527/20190108/920b-hrkkwef7015202.jpg" alt="img"></p>
<p>第三步和第四步是将分数除以8(8是论文中使用的键向量的维数64的平方根，这会让梯度更稳定。这里也可以使用其它值，8只是默认值)，然后通过softmax传递结果。softmax的作用是使所有单词的分数归一化，得到的分数都是正值且和为1。</p>
<p><img src="https://n.sinaimg.cn/sinacn20116/22/w943h679/20190108/602d-hrkkwef7015373.jpg" alt="img"></p>
<p>这个softmax分数决定了每个单词对编码当下位置（“Thinking”）的贡献。显然，已经在这个位置上的单词将获得最高的softmax分数，但有时关注另一个与当前单词相关的单词也会有帮助。</p>
<p>第五步是将每个值向量乘以对应key的softmax分数。这里的直觉是希望关注语义上相关的单词，并弱化不相关的单词(例如，让它们乘以0.001这样的小数)。</p>
<p>第六步是对加权值向量求和（译注：自注意力的另一种解释就是在编码某个单词时，就是将所有单词的表示（值向量）进行加权求和，而权重是通过该词的表示（键向量）与被编码词表示（查询向量）的点积并通过softmax得到。），然后即得到自注意力层在该位置的输出(在我们的例子中是对于第一个单词)。<br><img src="https://n.sinaimg.cn/sinacn20116/669/w746h723/20190108/ad95-hrkkwef7015564.jpg" alt="img"></p>
<p>这样自注意力的计算就完成了。得到的向量就可以传给前馈神经网络。然而实际中，这些计算是以矩阵形式完成的，以便算得更快。那我们接下来就看看如何用矩阵实现的。</p>
<h3 id="通过矩阵运算实现自注意力机制"><a href="#通过矩阵运算实现自注意力机制" class="headerlink" title="通过矩阵运算实现自注意力机制"></a>通过矩阵运算实现自注意力机制</h3><p>第一步是计算查询矩阵、键矩阵和值矩阵。为此，我们将将输入句子的词嵌入装进矩阵X中，将其乘以我们训练的权重矩阵(W^Q^，W^K^，W^V^)。</p>
<p>x矩阵中的每一行对应于输入句子中的一个单词。我们再次看到词嵌入向量 (512，或图中的4个格子)和q&#x2F;k&#x2F;v向量(64，或图中的3个格子)的大小差异。</p>
<p>最后，由于我们处理的是矩阵，我们可以将步骤2到步骤6合并为一个公式来计算自注意力层的输出。<br><img src="https://jalammar.github.io/images/t/self-attention-matrix-calculation-2.png" alt="img"></p>
<h3 id="多头注意力"><a href="#多头注意力" class="headerlink" title="多头注意力"></a>多头注意力</h3><p>通过增加一种叫做“多头”注意力（“multi-headed” attention）的机制，论文进一步完善了自注意力层，并在两方面提高了注意力层的性能：</p>
<p>1.它扩展了模型专注于不同位置的能力。在上面的例子中，虽然每个编码都在z1中有或多或少的体现，但是它可能被实际的单词本身所支配。如果我们翻译一个句子，比如“The animal didn’t cross the street because it was too tired”，我们会想知道“it”指的是哪个词，这时模型的“多头”注意机制会起到作用。</p>
<p>2.它给出了注意力层的多个“表示子空间”（representation subspaces）。接下来我们将看到，对于“多头”注意机制，我们有多个查询&#x2F;键&#x2F;值权重矩阵集(Transformer使用八个注意力头，因此我们对于每个编码器&#x2F;解码器有八个矩阵集合)。这些集合中的每一个都是随机初始化的，在训练之后，每个集合都被用来将输入词嵌入(或来自较低编码器&#x2F;解码器的向量)投影到不同的表示子空间中。</p>
<p>在“多头”注意机制下，我们为每个头保持独立的查询&#x2F;键&#x2F;值权重矩阵，从而产生不同的查询&#x2F;键&#x2F;值矩阵。和之前一样，我们拿X乘以W^Q^&#x2F;W^K^&#x2F;W^V^矩阵来产生查询&#x2F;键&#x2F;值矩阵。</p>
<p>如果我们做与上述相同的自注意力计算，只需八次不同的权重矩阵运算，我们就会得到八个不同的Z矩阵。<br><img src="https://n.sinaimg.cn/sinacn20116/639/w951h488/20190108/8b6b-hrkkwef7015744.png" alt="img"></p>
<p>这给我们带来了一点挑战。前馈层不需要8个矩阵，它只需要一个矩阵(由每一个单词的表示向量组成)。所以我们需要一种方法把这八个矩阵压缩成一个矩阵。那该怎么做？其实可以直接把这些矩阵拼接在一起，然后用一个附加的权重矩阵W^O^与它们相乘。</p>
<p><img src="https://n.sinaimg.cn/front/53/w1080h573/20190108/MGNp-hrkkwef7009086.jpg" alt="img"></p>
<p>这几乎就是多头自注意力的全部。这确实有好多矩阵，我们试着把它们集中在一个图片中，这样可以一眼看清。</p>
<p><img src="https://n.sinaimg.cn/front/79/w1080h599/20190108/aEDY-hrkkwef7009206.jpg" alt="img"></p>
<h3 id="使用位置编码表示序列的顺序"><a href="#使用位置编码表示序列的顺序" class="headerlink" title="使用位置编码表示序列的顺序"></a>使用位置编码表示序列的顺序</h3><p>到目前为止，我们对模型的描述缺少了一种理解输入单词顺序的方法。</p>
<p>为了解决这个问题，Transformer为每个输入的词嵌入添加了一个向量。这些向量遵循模型学习到的特定模式，这有助于确定每个单词的位置，或序列中不同单词之间的距离。这里的直觉是，将位置向量添加到词嵌入中使得它们在接下来的运算中，能够更好地表达的词与词之间的距离。</p>
<p><img src="https://n.sinaimg.cn/front/92/w1080h612/20190108/Mjnu-hrkkwef7009436.jpg" alt="img"></p>
<p>为了让模型理解单词的顺序，我们添加了位置编码向量，这些向量的值遵循特定的模式。</p>
<p>如果我们假设词嵌入的维数为4，则实际的位置编码如下：</p>
<h2 id="残差模块"><a href="#残差模块" class="headerlink" title="残差模块"></a>残差模块</h2><p>在继续进行下去之前，我们需要提到一个编码器架构中的细节：在每个编码器中的每个子层（自注意力、前馈网络）的周围都有一个残差连接，并且都跟随着一个“层-归一化”步骤。</p>
<p>层-归一化步骤：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1607.06450">https://arxiv.org/abs/1607.06450</a></p>
<p><img src="https://n.sinaimg.cn/front/8/w960h648/20190108/9QcV-hrkkwef7009734.jpg" alt="img"></p>
<p>If we’re to visualize the vectors and the layer-norm operation associated with self attention, it would look like this:</p>
<p><img src="https://jalammar.github.io/images/t/transformer_resideual_layer_norm_2.png" alt="img"></p>
<p>解码器的子层也是这样的。如果我们想象一个2层编码-解码结构的transformer，它看起来会像下面这张图一样：</p>
<p><img src="https://jalammar.github.io/images/t/transformer_resideual_layer_norm_3.png" alt="img"></p>
<h3 id="解码组件"><a href="#解码组件" class="headerlink" title="解码组件"></a>解码组件</h3><p>既然我们已经谈到了大部分编码器的概念，那么我们基本上也就知道解码器是如何工作的了。但最好还是看看解码器的细节。</p>
<p>首先，编码器处理输入序列，顶端编码器的输出之后会转化为一个包含向量K（键向量）和V（值向量）的注意力向量集 。这些向量将被每个解码器用于自身的“编码-解码注意力层”，而这些层可以帮助解码器重点关注输入序列中的合适位置：</p>
<p><img src="https://jalammar.github.io/images/t/transformer_decoding_1.gif" alt="img"></p>
<p>在完成编码阶段后，即开始解码阶段。解码阶段的每个步骤都会输出一个输出序列中的元素（在这个例子里，输出序列是翻译成英语的句子）</p>
<p>接下来的步骤重复了这个过程，直到到达一个特殊的终止符号，它表示transformer的解码器已经完成了它的输出。每个步骤的输出在下一个时间步被提供给底端解码器，并且就像编码器之前做的那样，这些解码器会输出它们的解码结果 。另外，就像我们对编码器的输入所做的那样，我们会嵌入并添加位置编码给那些解码器，来表示每个单词的位置。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_decoding_2.gif" alt="img"><br>而那些解码器中的自注意力层表现的模式与编码器不同：在解码器中，自注意力层只被允许处理输出序列中前面的那些位置。在softmax步骤前，它会把后面的位置给隐去（把它们设为-inf)。</p>
<p>这个“编码-解码注意力层”工作方式基本就像多头自注意力层一样，只不过它是通过它下方的层来创造查询矩阵，并且从编码器的输出中取得键&#x2F;值矩阵。</p>
<h3 id="最终的线性变换和Softmax层"><a href="#最终的线性变换和Softmax层" class="headerlink" title="最终的线性变换和Softmax层"></a>最终的线性变换和Softmax层</h3><p>解码组件最后会输出一个实数向量。我们如何把浮点数变成一个单词？这便是线性变换层要做的工作，它之后就是Softmax层。</p>
<p>线性变换层是一个简单的全连接神经网络，它可以把解码组件产生的向量投射到一个比它大得多的、被称作对数几率（logits）的向量里。</p>
<p>不妨假设我们的模型从训练集中学习一万个不同的英语单词（我们模型的“输出词表”）。因此对数几率向量为一万个单元格长度的向量——每个单元格对应某一个单词的分数。</p>
<p>接下来的Softmax 层便会把那些分数变成概率（都为正数、上限1.0）。概率最高的单元格被选中，并且它对应的单词被作为这个时间步的输出。</p>
<p><img src="https://n.sinaimg.cn/front/681/w907h574/20190108/ru1--hrkkwef7009838.jpg" alt="img"></p>
<p>这张图片从底部以解码器组件产生的输出向量开始。之后它会转化出一个输出单词。</p>
<h3 id="训练部分总结"><a href="#训练部分总结" class="headerlink" title="训练部分总结"></a>训练部分总结</h3><p>既然我们已经过了一遍完整的transformer的前向传播过程，那我们就可以直观感受一下它的训练过程。</p>
<p>在训练过程中，一个未经训练的模型会通过一个完全一样的前向传播。但因为我们用有标记的训练集来训练它，所以我们可以用它的输出去与真实的输出做比较。</p>
<p>为了把这个流程可视化，不妨假设我们的输出词汇仅仅包含六个单词：“a”, “am”, “i”, “thanks”, “student”以及 “<eos>”（end of sentence的缩写形式）。</p>
<p><img src="https://n.sinaimg.cn/front/592/w1080h312/20190108/-K91-hrkkwef7009953.png" alt="img"></p>
<p>我们模型的输出词表在我们训练之前的预处理流程中就被设定好。</p>
<p>一旦我们定义了我们的输出词表，我们可以使用一个相同宽度的向量来表示我们词汇表中的每一个单词。这也被认为是一个one-hot 编码。所以，我们可以用下面这个向量来表示单词“am”：</p>
<p><img src="https://n.sinaimg.cn/front/793/w1080h513/20190108/9pvb-hrkkwef7010082.jpg" alt="img"></p>
<p>例子：对我们输出词表的one-hot 编码</p>
<p>接下来我们讨论模型的损失函数——这是我们用来在训练过程中优化的标准。通过它可以训练得到一个结果尽量准确的模型。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>比如说我们正在训练模型，现在是第一步，一个简单的例子——把“merci”翻译为“thanks”。</p>
<p>这意味着我们想要一个表示单词“thanks”概率分布的输出。但是因为这个模型还没被训练好，所以不太可能现在就出现这个结果。</p>
<p><img src="https://jalammar.github.io/images/t/transformer_logits_output_and_label.png" alt="img"></p>
<p>因为模型的参数（权重）都被随机的生成，（未经训练的）模型产生的概率分布在每个单元格&#x2F;单词里都赋予了随机的数值。我们可以用真实的输出来比较它，然后用反向传播算法来略微调整所有模型的权重，生成更接近结果的输出。</p>
<p>如何比较两个概率分布？我们可以简单地用其中一个减去另一个。更多细节请参考交叉熵和KL散度。</p>
<p>交叉熵：<a target="_blank" rel="noopener" href="https://colah.github.io/posts/2015-09-Visual-Information/">https://colah.github.io/posts/2015-09-Visual-Information/</a></p>
<p>KL散度：<a target="_blank" rel="noopener" href="https://www.countbayesie.com/blog/2017/5/9/kullback-leibler-divergence-explained">https://www.countbayesie.com/blog/2017/5/9/kullback-leibler-divergence-explained</a></p>
<p>但注意到这是一个过于简化的例子。更现实的情况是处理一个句子。例如，输入“je suis étudiant”并期望输出是“i am a student”。那我们就希望我们的模型能够成功地在这些情况下输出概率分布：</p>
<p>每个概率分布被一个以词表大小（我们的例子里是6，但现实情况通常是3000或10000）为宽度的向量所代表。</p>
<p>第一个概率分布在与“i”关联的单元格有最高的概率</p>
<p>第二个概率分布在与“am”关联的单元格有最高的概率</p>
<p>以此类推，第五个输出的分布表示“<eos>”关联的单元格有最高的概率</p>
<p>目标概率分布：</p>
<p><img src="https://jalammar.github.io/images/t/output_target_probability_distributions.png" alt="img"></p>
<p>在一个足够大的数据集上充分训练后，我们希望模型输出的概率分布看起来像这个样子：</p>
<p><img src="https://jalammar.github.io/images/t/output_trained_model_probability_distributions.png" alt="img"></p>
<p>注意到每个位置（词）都得到了一点概率，即使它不太可能成为那个时间步的输出——这是softmax的一个很有用的性质，它可以帮助模型训练。</p>
<p>因为这个模型一次只产生一个输出，不妨假设这个模型只选择概率最高的单词，并把剩下的词抛弃。这是其中一种方法（叫贪心解码）。另一个完成这个任务的方法是留住概率最靠高的两个单词（例如I和a），那么在下一步里，跑模型两次：其中一次假设第一个位置输出是单词“I”，而另一次假设第一个位置输出是单词“me”，并且无论哪个版本产生更少的误差，都保留概率最高的两个翻译结果。然后我们为第二和第三个位置重复这一步骤。这个方法被称作集束搜索（beam search）。在我们的例子中，集束宽度是2（因为保留了2个集束的结果，如第一和第二个位置），并且最终也返回两个集束的结果（top_beams也是2）。这些都是可以提前设定的参数。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/12/I3D/">Two-Stream Inflated 3D ConvNets</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">日常学习笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/I3D/">I3D</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%A1%8C%E4%B8%BA%E8%AF%86%E5%88%AB/">行为识别</a></span><div class="content"><h1 id="Two-Stream-Inflated-3D-ConvNets"><a href="#Two-Stream-Inflated-3D-ConvNets" class="headerlink" title="Two-Stream Inflated 3D ConvNets"></a>Two-Stream Inflated 3D ConvNets</h1><blockquote>
<p>Paper：<a href="https://link.zhihu.com/?target=https://openaccess.thecvf.com/content_cvpr_2017/papers/Carreira_Quo_Vadis_Action_CVPR_2017_paper.pdf">Quo Vadis, action recognition? A new model and the kinetics dataset</a></p>
</blockquote>
<h2 id="1-主要贡献"><a href="#1-主要贡献" class="headerlink" title="1 主要贡献"></a>1 主要贡献</h2><p><strong>作者的Motivation主要是为了解决两个问题：</strong></p>
<p>（1）现有的数据集，如UCF-101和HMDB-51的视频数量都比较少，很多模型因此都获得了比较接近的效果，没法有效的对模型性能进行评价（如，我们在mnist数据集上，可能自己随便搭个三五层网络，和efficinet-b7的准确率可能都是0.99+，没有办法有效的评价不同模型的好坏）。</p>
<p>为什么作者想要对之前的模型进行比较？对于视频行为识别来说，不同于图像任务，各种方法层出不穷，如<strong>Fig. 2</strong> 所示。输入数据可以有RGB视频或者额外的光流，网络结构有3D卷积、双流、2D卷积+LSTM等等。谁也不好说哪种方法更好。</p>
<p><img src="https://pic4.zhimg.com/80/v2-fef44f03cb1ac9a5910d8f5ba575c3a7_720w.jpg" alt="img">Fig. 2 多种视频行为识别方案</p>
<p>（2）Imagenet图像分类中出现了很多优秀的网络结构，并且这些模型和他们在Imagenet上的预训练权重能够很好的扩展应用到其他领域，如目标检测，分割等等。但是这些任务能够通过预训练+微调的方式获得一定的提升，是不是因为他们都是在Spatial领域呢？对于视频行为识别来说，多了一个Temporal领域，预训练模型能不能仍然work呢？</p>
<p><strong>针对1.1中的两个问题，作者的解决方案包括：</strong></p>
<p>（1） 针对问题（1），作者提出了一个新的大型视频行为识别数据集 <strong>Kinetics</strong> Human Action Video dataset。这个数据集比UCF-101和HMDB-51大了两个数量级。包括400个人类动作的类别，每个类别都有超过400个clips。数据集是从Youtube中搜集的真实场景下的视频。</p>
<p>（2）对于视频行为识别任务来说，如 <strong>Fig. 3</strong> 所示，相较于图像分类等任务，多了一个时间维度。而Imagenet挑战赛中的各种2D卷积网络没有办法同时提取时空信息，怎么把2D卷积的权重，扩展到3D卷积上呢？作者提出了一种方法（很简单，后面具体介绍），并且基于这种方法，提出了<strong>Two-Stream Inflated 3D ConvNets (I3D)</strong> 模型。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ae9afcc13e21f9c7df5ed852df3bd3c2_720w.jpg" alt="img">Fig. 3 2D卷积核的预训练权重怎么应用到3D卷积核上？</p>
<p>（3）既然可以尝试把Imagenet中的预训练权重扩展到视频行为识别中来，那么在视频行为识别中，作者也实验了在大型的数据集（作者提出的Kinetics数据集）上预训练，然后在UCF-101和HMDB-51上微调的方案。</p>
<h2 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2 主要方法"></a>2 主要方法</h2><h3 id="2-1-本文实验的其他视频行为识别模型设置"><a href="#2-1-本文实验的其他视频行为识别模型设置" class="headerlink" title="2.1 本文实验的其他视频行为识别模型设置"></a>2.1 本文实验的其他视频行为识别模型设置</h3><p><strong>2.1.1 2D CNN + LSTM</strong></p>
<p>由于2D分类网络的效果好，想到把其用在video上。使用2D CNN的好处是可以直接从Imagenet的预训练权重迁移过来，但是只用那些2D卷积网络不能捕捉时空方面的信息，因此使用LSTM提取时序特征。流程是，首先使用2D网络分别提取每一帧图像的特征，然后对于所有特征使用LSTM来获取帧之间的时序信息。</p>
<p>作者使用Inception-V1作为2D CNN骨干网络，把最后一个平均池化输出的512维特征向量输入作为LSTM一个step的输入，再使用一个全连接层作为分类器。</p>
<p>使用交叉熵损失，训练时对于每一个step的输出都计算Loss。测试时使用最后一个step的输出类别作为结果。</p>
<p>这种方法的<strong>优点</strong>是可以直接使用2D网络的预训练权重；<strong>缺点</strong>是只有在LSTM的部分才能够基于高维抽象的特征进行运动信息的提取，损失了很多低等级的运动信息，此外LSTM训练时需要在每个step都进行反向传播。</p>
<p><strong>2.1.2 3D CNN</strong></p>
<p>如果说2D卷积是解决各种图像任务的天选之子，那么3D卷积就是提取时空特征时最自然的解决方案，如C3D，可以参考文章：</p>
<p>[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/443813567">论文笔记] C3D - 知乎 (zhihu.com)</a></p>
<p>其<strong>优点</strong>就是可以同时提取时空信息；<strong>缺点</strong>也显而易见，即具有更庞大的参数数量从而更难训练，因此一般3D网络的深度都较浅，单这样又影响了模型的表达能力，此外，没有办法能够有效的把2D网络的预训练权重迁移到3D网络。</p>
<p>本文作者在C3D的基础上进行了改进：（1）在所有卷积和全连接层之后都假如了BN，（2）原始C3D的第一个池化步长是 $$ 1 \times 2 \times 2 $$ ，本文改为了  $$ 2 \times 2 \times 2 $$ ，因此能够更加节省显存占用（可以使用更大的Batch，对于BN来说这也是非常重要的)。</p>
<p><strong>2.1.3 Two-Stream</strong></p>
<p>双流网络中一个分支作为spatial flow，输入RGB图像来提取物体和场景外观特征；另一个分支作为temporal flow，输入光流来提取运动特征。通常两个网络分开训练，只有在测试时才会平均两个网络的预测（测试的时候是输入很多个单张图，最后结果取平均）。因此，也产生了时空信息在浅层网络中无法有效融合的问题。</p>
<p><strong>2.1.4 3D-fused Two-stream</strong></p>
<p>双流的一个改进：在最后一层卷积层之后，使用3D ConvNet把空间流和时间流<strong>融合</strong>（相比于传统双流是在softmax后才做fusion，把softmax输出的score进行平均）。输入网络的是相隔10帧采样的5个连续RGB帧。</p>
<h3 id="2-2-Two-Stream-Inflated-3D-ConvNets-（I3D）-网络结构"><a href="#2-2-Two-Stream-Inflated-3D-ConvNets-（I3D）-网络结构" class="headerlink" title="2.2 Two-Stream Inflated 3D ConvNets （I3D） 网络结构"></a><strong>2.2 Two-Stream Inflated 3D ConvNets （I3D） 网络结构</strong></h3><p>作者使用Inception-V1[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/445736110#ref_1">1]</a>作为骨干网络，其网络结构如图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-1d6b29eff4be9ca7c1349ffe440d1b7d_720w.jpg" alt="img">Fig. 4 Inception-V1网络结构</p>
<p><strong>2.2.1 2D网络到3D网络</strong></p>
<p>Imagenet挑战赛中有很多优秀的模型，想使用他们的3D版本包括两个步骤：（1）模型从2D变成3D，（2）权重从2D变成3D。</p>
<p>对于模型，本文直接把2D卷积或2D池化的 $$ N \times N $$ 的kernel变成  $$ N \times N \times N $$ 的kernel。</p>
<p>对于预训练权重，首先把2D卷积核在时间维度上复制N份，然后除以时间维度的维度N，这样做是为了扩展到3D卷积之后，每一层都仍然获取到类似大小的输出相应。如果不除以N，就会出现输出相应会增大N倍，改变了预训练时网络所学习到的数据分布。</p>
<p><strong>2.2.2 池化窗口、步长和卷积步长应该怎么设置？</strong></p>
<p>我们已经把2D卷积核扩展成为了3D卷积核。但是2D池化窗口 $$k \times k$$ ，2D池化步长 $$ s_p \times s_p $$，2D卷积核的步长 $$s_c \times s_c$$ 应该怎么扩展到3D？</p>
<p>一个自然的想法是向卷积核一样，把2D  $$k \times k$$  的池化窗口直接变成  $$k \times k \times k$$  ，同理步长也都直接对称的扩展。但是考虑输入图像的高宽，以及时间维度的尺度差异，如果简单的在时间维度也使用相同的池化窗口，则会导致时间维度过快的变化，可能在浅层网络中把不同时间中的边缘特征进行过早的混合，影响空间特征的提取；而如果时间维度的窗口或步长太小，则可能导致不能有效的提取空间动态信息。</p>
<p>至于怎么设置池化窗口、步长，还有卷积的步长，主要依赖于视频帧率和输入分辨率。本文作者在Inception-V1中的设置为（如<strong>Fig. 1</strong>所示）：</p>
<ul>
<li>前两个池化窗口为 $$3 \times 3$$ ，步长 $$2 \times 2$$ 的max pool扩展为池化窗口为  ，$$1 \times 3 \times 3$$步长为  。即$$1 \times 2 \times 2$$不过早的增大时间维度感受野，浅层网络中更加倾向于提取空间特征。</li>
<li>中间两个池化窗口为$$3 \times 3$$，步长 $$2 \times 2$$的max pool扩展为池化窗口为  $$3 \times 3 \times 3$$，步长为 $$2 \times 2 \times 2 $$。</li>
<li>最后一个avg pool的池化窗口扩展为 $$2 \times 7 \times 7$$ 。</li>
<li>Inception Module中的池化都扩展为和高、宽维度相同的窗口大小、步长。</li>
</ul>
<h3 id="2-3-训练"><a href="#2-3-训练" class="headerlink" title="2.3 训练"></a>2.3 训练</h3><ul>
<li>双流的两个分支在训练时分别训练，在测试时取平均。</li>
<li>对于所有的卷积层，都由一个BN和ReLU。</li>
<li>SGD + momentum&#x3D;0.9</li>
<li>把视频最短边resize到256，然后random crop $$224 \times 224$$ ，随机水平翻转。</li>
<li>如果视频较短，循环视频知道满足输入。</li>
<li>使用TV-L1算法计算光流。</li>
</ul>
<h2 id="3-细节问题"><a href="#3-细节问题" class="headerlink" title="3 细节问题"></a>3 细节问题</h2><h3 id="3-1-2D卷积核（和权重）为什么可以直接复制N次得到3D卷积核？3D卷积的权重为什么要除以N？"><a href="#3-1-2D卷积核（和权重）为什么可以直接复制N次得到3D卷积核？3D卷积的权重为什么要除以N？" class="headerlink" title="3.1 2D卷积核（和权重）为什么可以直接复制N次得到3D卷积核？3D卷积的权重为什么要除以N？"></a>3.1 2D卷积核（和权重）为什么可以直接复制N次得到3D卷积核？3D卷积的权重为什么要除以N？</h3><p>我们首先不考虑使用在Imagenet上的预训练权重来把2D卷积扩展称为3D卷积。那么能直接使用3D卷积在Imagenet上预训练吗？</p>
<p>假设我们有一个视频片段，其中的物体移动非常慢，几乎没有运动（比如摄像头拍向一块空地）。我们在这段视频中取一些帧出来，比如取16帧，拼接起来作为3D卷积网络的输入。那么我们可以认为取出来的16帧等价于1帧图像复制16份（视频中几乎没有运动）。</p>
<p>我们按照这个思路来考虑使用Imagenet来直接预训练3D卷积网络，即在Imagenet中取出1张图像，复制16份并拼接作为输入视频（boring video）。然后使用3D卷积来提取特征就可以了。</p>
<p>我们来拆分一下3D卷积核 $$h \times w \times t$$ ，分解成$$t$$个$$h \times w$$的2D卷积核。这里的$$h,w$$分别是卷积核的高宽，  是时间$$t$$维度的深度，也就是我们把imagenet中的1张图像叠加16份的”16”。 $$h \times w$$ 作用在$$t=16$$上的任意帧时，所提取的空间特征都应该是完全相同的，因为叠加的每一帧都是1张图像复制来的。</p>
<p>所以把2D卷积核复制N次得到3D卷积核，等价于把1张静态图像复制拼接为boring video，然后使用3D卷积核去预训练是等价的。</p>
<p>但是，由2D卷积核预训练权重复制得到的3D卷积核，为什么权重还要除以N？</p>
<p>还是考虑把imagenet中的1帧图像复制16份拼接成一个boring video。使用2D卷积时，其权重假设分别为:</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin+%7Barray%7D%7B1%7D+0.1+&+0.2+&+0.3+%5C%5C+0.4+&+0.5+&+0.6+%5C%5C+0.7+&+0.8+&+0.9+%5C%5C+%5Cend+%7Barray%7D" alt="[公式]"> </p>
<p>提取特征图上的一块 $$3 \times 3$$ 区域的像素</p>
<p> <img src="https://www.zhihu.com/equation?tex=%5Cbegin+%7Barray%7D%7B1%7D+x_1+&+x_2+&+x_3+%5C%5C+x_4+&+x_5+&+x_6+%5C%5C+x_7+&+x_8+&+x_9+%5C%5C+%5Cend+%7Barray%7D" alt="[公式]"> </p>
<p>得到1个输出值</p>
<p> <img src="https://www.zhihu.com/equation?tex=x_%7Bout%7D+=+0.1x_1+++0.2x_2+++0.3x_3+++0.4x_4+++...+++0.9x_9" alt="[公式]"></p>
<p>如果使用通过2D卷积复制来的3D卷积时，得到的1个输出值为： <img src="https://www.zhihu.com/equation?tex=x_%7Bout%7D+=+3+%5Ctimes+(0.1x_1+++0.2x_2+++0.3x_3+++0.4x_4+++...+++0.9x_9)" alt="[公式]"> </p>
<p>则改变了下一层卷积的输入特征响应激活值了，所以要对2D卷积核的权重进行归一化， 即除以N。</p>
<h3 id="3-2-作者使用基于3D卷积的双流网络，为什么不直接使用3D网络，而是引入额外的光流输入？"><a href="#3-2-作者使用基于3D卷积的双流网络，为什么不直接使用3D网络，而是引入额外的光流输入？" class="headerlink" title="3.2 作者使用基于3D卷积的双流网络，为什么不直接使用3D网络，而是引入额外的光流输入？"></a>3.2 作者使用基于3D卷积的双流网络，为什么不直接使用3D网络，而是引入额外的光流输入？</h3><p><img src="https://pic2.zhimg.com/80/v2-4e82002d38eed0231c0e382abf0a5201_720w.jpg" alt="img"></p>
<h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4 实验结果"></a>4 实验结果</h2><h3 id="4-1-Imagenet预训练"><a href="#4-1-Imagenet预训练" class="headerlink" title="4.1 Imagenet预训练"></a>4.1 Imagenet预训练</h3><p><img src="https://pic1.zhimg.com/80/v2-99f39d00e26bd8af45b85aa85009f60c_720w.jpg" alt="img"></p>
<p>可以发现，ImageNet then Kinetics中，准确率都有提高。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/12/attention/">Attention</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">日常学习笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/attention/">attention</a></span><div class="content"><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><a target="_blank" rel="noopener" href="https://github.com/xmu-xiaoma666/External-Attention-pytorch">xmu-xiaoma666&#x2F;External-Attention-pytorch: 🍀 Pytorch implementation of various Attention Mechanisms, MLP, Re-parameter, Convolution, which is helpful to further understand papers.⭐⭐⭐ (github.com)</a></p>
<h3 id="1-为什么要引入-Attention-机制？"><a href="#1-为什么要引入-Attention-机制？" class="headerlink" title="1 为什么要引入 Attention 机制？"></a>1 为什么要引入 Attention 机制？</h3><p>当我们用深度 CNN 模型识别图像时，一般是通过卷积核去提取图像的局部信息，然而，每个局部信息对图像能否被正确识别的影响力是不同的，如何让模型知道图像中不同局部信息的重要性呢？答案就是注意力机制。</p>
<p>试想，如果每个局部信息都不放过，那么必然耗费很多精力，不利于人类的生存进化。同样地，在深度学习网络中引入类似的机制，可以<strong>简化模型，加速计算</strong>。</p>
<p>另外，利用循环神经网络去处理 NLP 任务时，<strong>长距离“记忆”能力一直是个大难题，而引入“注意力机制”也能有效缓解这一问题。</strong></p>
<h3 id="2-Encoder-Decoder-框架"><a href="#2-Encoder-Decoder-框架" class="headerlink" title="2 Encoder-Decoder 框架"></a>2 Encoder-Decoder 框架</h3><p>注意力模型可以看作一种通用的思想，本森并不依赖于特定的框架，但目前大多数模型附着在Encoder-Decoder框架下，因此先从Encoder-Decoder框架开始讨论。</p>
<p>常见的深度学习模型有 CNN、RNN、LSTM、AE 等，其实都可以归为一种通用框架 - Encoder-Decoder.</p>
<p><img src="https://pic1.zhimg.com/80/v2-ac1a731879cc23c12e48bd7f16bb22c4_720w.jpg" alt="encoder-decoder"></p>
<p>在文本处理领域，有一类常见的任务就是从一个句子（Source）生成另一个句子（Target），比如翻译，其中 <strong>xi</strong> 是输入单词的向量表示，<strong>yi</strong> 表示输出单词。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ad908951ac78a46794d318393aff6d98_720w.jpg" alt="img"></p>
<p>Source 经过 Encoder，生成中间的语义编码 <strong>C</strong>，</p>
<p><img src="https://pic3.zhimg.com/80/v2-9ee51cdd6c504ee06f9d302ae696f136_720w.jpg" alt="img"></p>
<p>C 经过 Decoder 之后，输出翻译后的句子。在循环神经网络中，先根据 <strong>C</strong> 生成 <strong>y1</strong>，再基于（<strong>C，y1</strong>）生成 <strong>y2</strong>，依此类推。</p>
<p><img src="https://pic3.zhimg.com/80/v2-92ddbfa766f17268af80a76dd6be974a_720w.jpg" alt="img"></p>
<h3 id="3-Soft-Attention-模型"><a href="#3-Soft-Attention-模型" class="headerlink" title="3 Soft Attention 模型"></a>3 Soft Attention 模型</h3><p><img src="https://pic1.zhimg.com/80/v2-29c7b6c7552f60c5039856077aa50a54_720w.jpg" alt="img">RNN 模型</p>
<p>传统的循环神经网络中，<strong>y1</strong>、<strong>y2</strong> 和 <strong>y3</strong> 的计算都是基于同一个 <strong>C</strong>. 深入思考一下，发现这可能并不是最好的方案，因为 Source 中不同单词对 <strong>y1</strong>、<strong>y2</strong> 和 <strong>y3</strong> 的影响是不同的，所以，很自然地就有了如下思路：</p>
<p><img src="https://pic2.zhimg.com/80/v2-7260651c60d95f617fe9a918132f4585_720w.jpg" alt="img">引入注意力机制的 Encoder-Decoder 框架</p>
<p><strong>上述改良模型中的 C1、C2、C3</strong> <strong>是怎么计算的呢？</strong>其实也非常简单，就是在计算 <strong>C1</strong>、<strong>C2</strong> 和 <strong>C3</strong> 时，分别使用不同的权重向量：</p>
<p><img src="https://pic3.zhimg.com/80/v2-1661a288d50be24fad370cf41e284156_720w.jpg" alt="img"></p>
<p>上述公式中的权重向量 (a11, a12, a13)、(a21, a22, a23)、(a31, a32, a33) 又是如何计算的呢？请看下图。</p>
<p><img src="https://pic1.zhimg.com/80/v2-76fecb2c6aec26c63e5db808469611b0_720w.jpg" alt="img">注意力分配的概率计算</p>
<p>上述模型中： <strong>h1</strong> &#x3D; f(Tom)、<strong>h2</strong> &#x3D; f(<strong>h1</strong>, Chase)、<strong>h3</strong> &#x3D; f(<strong>h2</strong>, Jerry).</p>
<p>当计算出 <strong>Hi-1</strong> 之后，通过函数 F(<strong>hj</strong>,<strong>Hi-1</strong>) 获得输入语句中不同单词（Tom、Chase、Jerry）对目标单词 <strong>yi</strong> 的影响力，F 的输出再经过 Softmax 进行归一化就得到了符合概率分布取值区间的注意力分配概率。其中，F 函数的实现方法有多种，比如余弦相似度、MLP 等。</p>
<p><img src="https://pic2.zhimg.com/80/v2-114439489a6c0dfa037521ded6a096c5_720w.jpg" alt="img">Google 神经网络机器翻译系统结构图</p>
<h3 id="4-Attention-机制的本质"><a href="#4-Attention-机制的本质" class="headerlink" title="4 Attention 机制的本质"></a>4 Attention 机制的本质</h3><p>现在，请你把 Source 想象成是内存里的一块存储空间，它里面存储的数据按 &lt;Key, Value&gt; 存储。给定 Query，然后取出对应的内容。<strong>这里与一般的 hash 查询方式不同的是，每个地址都只取一部分内容，然后对所有的 Value 加权求和。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-bdab75088ba037b48db6a5a85f62941a_720w.jpg" alt="img">Attention 的实质：软寻址（soft addressing）</p>
<p>公式描述如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-6f9d9ec94f3b5e05d4ab964cefb405da_720w.jpg" alt="img"></p>
<p>Attention 的计算可以分成如下三个阶段：</p>
<p><img src="https://pic1.zhimg.com/80/v2-f52572cd150732703a97d6a92305244c_720w.jpg" alt="img">三阶段计算 Attention 过程</p>
<p><img src="https://pic2.zhimg.com/80/v2-b56ff5ce9327999ed1dde2da04fa3bc9_720w.jpg" alt="img"></p>
<p>注意力打分机制</p>
<p><img src="https://pic4.zhimg.com/80/v2-6ed835d05761d8988e74219ba381b38b_720w.jpg" alt="img"></p>
<p>归一化的注意力概率分配</p>
<p><img src="https://pic4.zhimg.com/80/v2-6e982a357c11c6c92058ea388148a3c7_720w.jpg" alt="img"></p>
<p>上述公式中的 <em>Lx</em> 表示输入语句的长度。上一节的例子中，Key 是等于 Value 的。</p>
<h3 id="5-Self-Attention-模型"><a href="#5-Self-Attention-模型" class="headerlink" title="5 Self Attention 模型"></a>5 Self Attention 模型</h3><p><img src="https://pic1.zhimg.com/80/v2-54d5f264438195cf41f569b3f1167880_720w.jpg" alt="img">可视化 Self Attention 例子</p>
<p>在 Soft Attention 模型中，Source 和输出 Target 的内容是不同的，比如中-英机器翻译，Source 对应中文语句，Target 对应英文语句。</p>
<p>现在有另一个任务，如上图所示：给定一个句子和句子中某个单词 making，如何找出与 making 强相关的其他单词呢？比如上图中的 more difficult（因为它们和 making 可以组成一个短语）.</p>
<p>这就用到了 Self Attention 机制，顾名思义，指的是 Source 内部元素之间或者 Target 内部元素之间发生的 Attention 机制，也可以理解为 Source &#x3D; Target 这种特殊情况下的 Attention 机制，具体计算过程和 Soft Attention 是一样的。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>下图展示了注意力机制如何在图片描述任务（Image-Caption）中发挥作用的。</p>
<p>图片描述任务，就是给你一张图片，请输出一句话去描述它。一般会用 CNN 来对图片进行特征提取，Decoder 部分使用 RNN 或者 LSTM 来输出描述语句。此时如果加入注意力机制，能够大大改善输出效果。</p>
<p><img src="https://pic4.zhimg.com/80/v2-3251b16a739ff649c4c13e217c2f73eb_720w.jpg" alt="img">图片描述任务中的注意力机制</p>
<p>另外，在语音识别、目标物体检测等领域，注意力机制同样取得了很好的效果。</p>
<p>实际上，<strong>Attention 机制听起来高大上，其关键就是学出一个权重分布，然后作用在特征上</strong>。</p>
<ul>
<li>这个权重可以保留所有的分量，叫加权（Soft Attention），也可以按某种采样策略选取部分分量（Hard Attention）。</li>
<li>这个权重可以作用在原图上，如目标物体检测；也可以作用在特征图上，如 Image-Caption</li>
<li>这个权重可以作用在空间尺度上，也可以作用于 Channel 尺度上，给不同通道的特征加权</li>
<li>这个权重可以作用在不同时刻上，如机器翻译</li>
</ul>
<h3 id="attention和全连接层的区别"><a href="#attention和全连接层的区别" class="headerlink" title="attention和全连接层的区别"></a>attention和全连接层的区别</h3><p>从结果上看，Attention的最终输出可以看成是一个“在关注部分权重更大的全连接层”。但是它与全连接层的区别在于，注意力机制可以利用输入的特征信息来确定哪些部分更重要。</p>
<p>举个例子：</p>
<p>输入层有A,B,C三个特征向量，我们需要构造一层网络来确定三者的权重，然后加权求和得到输出O。也就是得到三个权重 $$ w_A, w_B, w_C $$ ，然后得到 </p>
<p><img src="https://www.zhihu.com/equation?tex=O=w_AA+w_BB+w_CC" alt="[公式]"> 。</p>
<p>这个式子形式上看上去确实是全连接层没错。然而如果用全连接层有什么问题呢？</p>
<p><strong>问题就在于在全连接层里， $$ w_A, w_B, w_C $$  是根据位置确定的。</strong>我第一次给你三个数据ABC，然后你得出了B最重要，也就是让 $$w_B$$ 最大。然而我下次给你的顺序可能是BAC，这次A在刚才B的位置，如果你用全连接层来实现的话，得出的结果就会变成 <img src="https://www.zhihu.com/equation?tex=O=w_AB+w_BA+w_CC" alt="[公式]"> 。这就变成了A最重要了，这显然不是我们想要的结果。</p>
<p>那么如何解决这个问题呢？我们就要根据实体自身的特征，而不是它们的位置来确定它们的重要程度。也就是说，  $$ w_A, w_B, w_C $$ 不该是固定的，而是要与A,B,C的值相关。简单考虑，也就是要定义一个函数f，令</p>
<p><img src="https://www.zhihu.com/equation?tex=w_A=f(A),w_B=f(B),w_C=f(C)" alt="[公式]"> 。</p>
<p>于是我们就给每个实体分配了一个与它们的位置无关的权重。<strong>这里的函数f就是我们所说的注意力机制。</strong>注意力机制f的定义方式有很多种，但是不属于这个问题的范围，这里我就不讨论了。</p>
<p>我们最终得出的输出为</p>
<p><img src="https://www.zhihu.com/equation?tex=O=w_AA+w_BB+w_CC=f(A)A+f(B)B+f(C)C" alt="[公式]"> </p>
<p>可以看出，最终整合信息时加权求和的形式没有变，所以可能是这样才让题主产生了注意力机制与全连接层没有区别的疑惑。然而事实上<strong>注意力机制的意义是引入了权重函数f，使得权重与输入相关，从而避免了全连接层中权重固定的问题。</strong></p>
<p>全连接的作用的是对一个实体进行从一个特征空间到另一个特征空间的映射，而注意力机制是要对来自同一个特征空间的多个实体进行整合。</p>
<p>实际上在实现方式上，Attention和全连接层可以说没有什么太大的区别。比如说，网络的第一层fc Layer，我们可以认为对于输入向量的不同维度给了一组不同的权重进行组合，然后将它们映射到另一个不同维度的向量空间。这组权重如果我们把它看做Attention机制的话，这组权重同样关注了不同的输入特征。甚至这个fc层和Attention机制区别只在于以下两点：</p>
<ol>
<li>同样是给予输入特征不同的权重进行更深层的网络学习，fc Layer只能是在整个网络的训练过程中得到，而基于Attention机制的Layer可以通过更多的方式去获得权重。</li>
<li>Attention Layer目的在于关注局部信息，所以输出和输入是在同一个向量空间的。这一点同样表现在Attention Layer和fc Layer的连接方式上。</li>
</ol>
<p>除了Attention机制带来的可解释性外，目前很多研究是基于Attention机制获得了效果提升，而二者最本质区别甚至只在于向量空间。为什么Attention机制能起到作用呢？个人想法是，Attention可以看做给予网络输入部分一个更好的超参数。<strong>传统的网络同样能够做到关注输入特征的局部信息，而Attention把关注局部信息这一重要部分单独进行设计，减少了整个网络的压力，使网络无需在输入特征的重要程度上下功夫，相对来说更多地关注了特征与结果的联系。</strong>简单来说，把网络看成你在做作业题。当你读题和解题的时候，会对题目描述的不同部分进行不同程度的关注，然后进行解题。但如果有人进行了题干分析，让你直接了解了题目描述哪些部分更重要时，那么做对的几率就会高好多。<strong>Attention机制和全连接层的差别，本质在于，让你费更少的力气读题，更多地去解题。</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/03/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">第一章-基础算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">日常学习笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></span><div class="content"><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>思想：分治法</strong></p>
<ol>
<li>确定分界点x。常用的是q[l],q[r],q[(l+r)&#x2F;2],随机</li>
<li><strong>调整区间</strong>。以x为分界点，左边所有的数小于等于x，右边所有的数大于等于x</li>
<li>递归处理左右两端</li>
</ol>
<p>最难点：第二步</p>
<h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><ol>
<li>创建两个数组a[] b[]</li>
<li>遍历q[l~r],把小于等于x的数放入a，大于x的数放入b</li>
<li>a[]-&gt;q[], b[]-&gt;q</li>
</ol>
<h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>双指针i和j分别指向区间两端，若q[i]&lt;x,i++,否则i停止移动;若q[j]&gt;x,j–，否则j停止移动;然后交换q[i]和q[j]</p>
<p>代码模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> x = q[l], i = l<span class="number">-1</span>, j = r+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">		<span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">		<span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后两行</p>
<p>quick_sort(q,l,j);<br>quick_sort(q,j+1,r);</p>
<p>若要把j改为i，则需要所有地方都对称改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> x = q[r], i = l<span class="number">-1</span>, j = r+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//这里不能用x=q[l]了，i取到l会出现边界问题</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">		<span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">		<span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,l,i<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,i,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>思想：分治法</strong></p>
<ol>
<li>把数组从中间分为两个区间left，right。中点：mid &#x3D; (l+r)&#x2F;2</li>
<li>递归排序left和right</li>
<li><strong>归并</strong></li>
</ol>
<p>最难点：合二为一</p>
<p>双指针法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> q[N],tmp[N]; <span class="comment">//需要一个额外的辅助数组tmp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>, i=l, j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">for</span>(i = l,j = <span class="number">0</span>; i&lt;=r; i++,j++)&#123;</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均时间复杂度：O(nlogn)<br>最佳时间复杂度：O(n)<br>最差时间复杂度：O(nlogn)<br>空间复杂度：O(n)<br>排序方式：In-place<br>稳定性：稳定</p>
<h3 id="打卡"><a href="#打卡" class="headerlink" title="打卡"></a>打卡</h3><h5 id="786-第k个数"><a href="#786-第k个数" class="headerlink" title="786. 第k个数"></a>786. 第k个数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] A = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        k = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) A[i] = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(quickSort(<span class="number">0</span>, n-<span class="number">1</span>, k-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> A[k];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> A[l], i = l-<span class="number">1</span>, j = r+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>(A[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>(A[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> A[i];</span><br><span class="line">                A[i] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= j) <span class="keyword">return</span> quickSort(l, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSort(j+<span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>本质：找边界</p>
<h4 id="有两种模板"><a href="#有两种模板" class="headerlink" title="有两种模板"></a>有两种模板</h4><h5 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid-1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>先写一个check函数</li>
<li>判断check(mid)是将区间划分为[l,mid-1]和[mid,r]，还是划分为[l,mid]和[mid+1,r]</li>
<li>如果是第一种情况（[l,mid-1]和[mid,r]），则要把mid改为(l+r+1)&#x2F;2。否则mid&#x3D;(l+r)&#x2F;2</li>
</ol>
<h5 id="例题-数的范围"><a href="#例题-数的范围" class="headerlink" title="例题-数的范围"></a>例题-数的范围</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分起始坐标（lower_bound)</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q[mid]&gt;=x) r = mid;</span><br><span class="line">    <span class="comment">/*//要找的是x的起始位置，则x右边的数应全部满足&gt;=x,因此check函数可写成判断是否&gt;=x。若是，则说明mid在x右边，且mid有可能是答案，因此应该在[l,mid]中寻找*/</span></span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;<span class="comment">//由于是分成了[l,mid]和[mid+1,r],mid不需要修改 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(q[l]!=x) cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/*如果序列中不存在x，则二分出来的是序列中第一个&gt;=x的数（或序列中的最后一个数？）因此只要判断q[l]!=x，就说明序列里没有x，可以直接输出不存在。*/</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="comment">//二分终止坐标(upper_bound)</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>, r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q[mid]&lt;=x) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;<span class="comment">//由于是分成了[l,mid-1]和[mid,r],mid=l+r+1&gt;&gt;1</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><h5 id="例题-开平方"><a href="#例题-开平方" class="headerlink" title="例题-开平方"></a>例题-开平方</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> l=<span class="number">0</span>,r=x;</span><br><span class="line"><span class="keyword">while</span>(r-l &gt; <span class="number">1e-8</span>)&#123;<span class="comment">//当两个浮点数足够接近就可认为是同一个数，经验值：至少要比题目要求的精度多两位。也可以循环固定次数。</span></span><br><span class="line">    <span class="type">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid*mid &gt;= x)<span class="comment">//mid&gt;=√x,应在mid左边搜索</span></span><br><span class="line">        r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><p>只有c++需要考虑。java和python本身能处理大整数。</p>
<p>由于输入位数较多，读入数据时以string的形式读入，然后<strong>逆序</strong>存到vector中。（由于要考虑到进位，最好把个位放在vector的开头，把最高位放在vector的结尾）</p>
<p>A和B都是正整数（如果题目有负数则在输入输出时处理，然后调用模板的函数）</p>
<h5 id="输入输出模板："><a href="#输入输出模板：" class="headerlink" title="输入输出模板："></a>输入输出模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a,b; <span class="comment">//记得include&lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A,B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) <span class="built_in">print</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="大整数加法"><a href="#大整数加法" class="headerlink" title="大整数加法"></a>大整数加法</h2><h6 id="A-B"><a href="#A-B" class="headerlink" title="A+B"></a>A+B</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>() || i&lt;B.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t+=B[i];</span><br><span class="line">        <span class="comment">//t = Ai+Bi+上一位的进位</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//t?</span></span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="大整数减法"><a href="#大整数减法" class="headerlink" title="大整数减法"></a>大整数减法</h2><h5 id="A-B-保证A-gt-x3D-B"><a href="#A-B-保证A-gt-x3D-B" class="headerlink" title="A-B(保证A&gt;&#x3D;B)"></a>A-B(保证A&gt;&#x3D;B)</h5><p>传入函数时，要先判断A和B的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))&#123;</span><br><span class="line">	<span class="keyword">auto</span> C = <span class="built_in">sub</span>(A,B);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) <span class="built_in">print</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B,A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) <span class="built_in">print</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//A=B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减法函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>; <span class="comment">//借位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        t = A[i]-t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t- = B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>); <span class="comment">//c++中负数取模运算结果是绝对值取模再加负号，(t+10)%10和t%10并不相等！！！</span></span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去掉前导零</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="大整数×小整数"><a href="#大整数×小整数" class="headerlink" title="大整数×小整数"></a>大整数×小整数</h2><h5 id="A×b-b-x3D-0-如果等于零直接输出0"><a href="#A×b-b-x3D-0-如果等于零直接输出0" class="headerlink" title="A×b(b!&#x3D;0 如果等于零直接输出0)"></a>A×b(b!&#x3D;0 如果等于零直接输出0)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>() || t; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t += A[i]*b; <span class="comment">//也可以在i&lt;A.size()循环结束后再处理多余的进位while(t)&#123;...&#125;</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="comment">//先判断b是否为0！！！</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>; i&lt;=<span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    	<span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,b);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>; i&lt;=<span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="大整数÷小整数"><a href="#大整数÷小整数" class="headerlink" title="大整数÷小整数"></a>大整数÷小整数</h2><h5 id="A÷b-b-x3D-0"><a href="#A÷b-b-x3D-0" class="headerlink" title="A÷b(b!&#x3D;0)"></a>A÷b(b!&#x3D;0)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;algorithm&gt;</span> <span class="comment">//reverse的头文件</span></span></span><br><span class="line"><span class="comment">//商是C，余数是r(通过引用传回去)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        r = r*<span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;<span class="comment">//除法是从高位开始的，因此C的顺序是高位在前低位在后</span></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());<span class="comment">//让C的顺序与其他的一致</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><p>对于数组</p>
$$
a_1,a_2,a_3... (a的下标从1开始！！！)
$$
<p>前缀和为</p>
$$
S_i = a_1+a_2+...+a_i
$$
<p>定义S<del>0</del>&#x3D;0</p>
<p>应用：求第l~第r个元素的和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];<span class="comment">//定义在外面的数组自动初始化为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="comment">//S[0]=0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p><img src="/2022/04/03/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20220303171052432.png" alt="二维前缀和"></p>
<p>S<del>ij</del>为a<del>ij</del>左上角区域所有元素的和。</p>
<p>x<del>1</del>y<del>1</del>到x<del>2</del>y<del>2</del>的面积为：</p>
$$
S_{x_2y_2}-S_{x_2,y_1-1}-S_{x_1-1,y2}+S_{x_1-1,y_1-1}
$$
<p>S<del>ij</del>的求法：</p>
$$
S_{ij}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{ij}
$$
<p>应用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2]-s[x2][y1<span class="number">-1</span>]-s[x1<span class="number">-1</span>][y2]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h4 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h4><p>前缀和的逆运算</p>
<p>构造b，使a为b的前缀和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">insert</span>(i,i,a[i]);<span class="comment">//构造b的过程也可以看作插入操作</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4>$$
b_{x_1y_1}\ +=\ c\\
b_{x_2+1,y1}\ -=c\ \\
b_{x1,y_2+1}\ -=\ c\\
b_{x_2+1,y_2+1}\ +=\ c
$$

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            b[i][j]+=b[i<span class="number">-1</span>][j]+b[i][j<span class="number">-1</span>]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;i&lt;=m;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>观察问题，将二重循环O(n^2^)优化到O(n)</p>
<p>暴力解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">        ...</span><br><span class="line">        j++;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="应用：最长连续不重复子序列"><a href="#应用：最长连续不重复子序列" class="headerlink" title="应用：最长连续不重复子序列"></a>应用：最长连续不重复子序列</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="comment">//s:用来记录a中的各元素的出现次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s[a[i]]++; <span class="comment">//a[i]出现次数++</span></span><br><span class="line">        <span class="keyword">while</span>(s[a[i]] &gt; <span class="number">1</span>)&#123; <span class="comment">//新加进去的a[i]引起了重复，因此重复的数一定是a[i]</span></span><br><span class="line">            s[a[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时，j和i之间已无重复元素</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&gt;&gt;res&gt;&gt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="n的二进制表示中第k位是几"><a href="#n的二进制表示中第k位是几" class="headerlink" title="n的二进制表示中第k位是几"></a>n的二进制表示中第k位是几</h2><ol>
<li>先把第k位移到最后一位 x &#x3D; n&gt;&gt;k</li>
<li>获取最后一位： x&amp;1</li>
</ol>
<h2 id="lowbit操作-树状数组常用"><a href="#lowbit操作-树状数组常用" class="headerlink" title="lowbit操作(树状数组常用)"></a>lowbit操作(树状数组常用)</h2><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><p>返回x的最后一个1的位置（二进制数表示）</p>
<p>如：x&#x3D;101000 ，lowbit(x)&#x3D;1000</p>
<h5 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h5><p>x&amp;-x</p>
<h5 id="应用-求x中有多少个1："><a href="#应用-求x中有多少个1：" class="headerlink" title="应用-求x中有多少个1："></a>应用-求x中有多少个1：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) x-=<span class="built_in">lowbit</span>(x),res++; <span class="comment">//每次去掉x的最后一个1</span></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>若一个序列的值域很大，但序列中元素的个数很少，在计算每个元素的出现次数时，若以通常的做法将序列里的值作为下标，则需要把数组开得很大,因此可以将每个元素映射到较小的元素</p>
<ol>
<li>a[]中可能有重复元素，需要去重</li>
<li>应能够快速算出a[i]离散化后的值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">//储存所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()); <span class="comment">//排序，方便去重</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>()); <span class="comment">//去重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分求出x对应的离散化后的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x) r=mid;<span class="comment">//找x的位置，既第一个大于等于x的数</span></span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>; <span class="comment">//把x映射到1,2,...,n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以前是直接用数组的值作为下标，离散化后是把数组中的值映射到下标</p>
<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; <span class="comment">//存放区间的左右端点</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>()); <span class="comment">//pair会优先以左端点排序，然后以右端点排序</span></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed=<span class="number">-2e9</span>; <span class="comment">// 负无穷，只要比数据范围的最小值小就行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg:segs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)&#123;</span><br><span class="line">            <span class="comment">//没有交集</span></span><br><span class="line">            <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ed = <span class="built_in">max</span>(ed,seg.second);</span><br><span class="line">            <span class="comment">//没有更新res里面当前st对应的ed？？？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">第二章-数据结构</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">日常学习笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></span><div class="content"><h1 id="链表与邻接表"><a href="#链表与邻接表" class="headerlink" title="链表与邻接表"></a>链表与邻接表</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="动态链表："><a href="#动态链表：" class="headerlink" title="动态链表："></a>动态链表：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试常考，但笔试不常用，因为太慢了</p>
<h4 id="静态链表："><a href="#静态链表：" class="headerlink" title="静态链表："></a>静态链表：</h4><ol>
<li>数组模拟单链表 常用：邻接表（用来存储图和树）</li>
<li>数组模拟双链表</li>
</ol>
<p>以下的实现不带空的头节点，head是一个指针，指向链表中的第一个元素。</p>
<h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head 指向链表中第一个元素的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示结点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示结点i的next</span></span><br><span class="line"><span class="comment">// idx 指向当前可分配的下一个位置</span></span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>; <span class="comment">//表示空集</span></span><br><span class="line">    idx = <span class="number">0</span>; <span class="comment">//下一个可以分配的位置从0开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入到表头（最常用）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先为新的点分配一个结点，把值存储进去</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    <span class="comment">// 修改指针</span></span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx; <span class="comment">//当前结点变为了第一个元素，head指向它</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入到下标为k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">    <span class="comment">//算法题里面不需要回收删掉的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除头节点</span></span><br><span class="line">head = ne[head];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h5><p>0号结点和1号结点分别为头节点和尾结点，不存储元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// l[i]和r[i]分别为第i个元素的前驱和后继</span></span><br><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里用0号位置代表表头，1号位置代表表尾</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标为k的点右边插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    <span class="comment">//一定要先调用r[k]再修改r[k]</span></span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第k个点（注意：单链表无法获取自己的前驱，因此只能删除指定位置之后的点，而双向链表可以获取前驱，因此可以直接删除指定位置的点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="type">int</span> k,x;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">0</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;R&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">insert</span>(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;D&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="built_in">remove</span>(k+<span class="number">1</span>); <span class="comment">//idx从2开始，第k个插入的数下标为k+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;IL&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            <span class="built_in">insert</span>(l[k+<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            <span class="built_in">insert</span>(k+<span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r[<span class="number">0</span>]; i!=<span class="number">1</span>; i=r[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h4 id="用数组模拟栈"><a href="#用数组模拟栈" class="headerlink" title="用数组模拟栈"></a>用数组模拟栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">stk[++t] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">tt--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>) 非空</span><br><span class="line"><span class="keyword">else</span> 空</span><br><span class="line">    </span><br><span class="line"><span class="comment">//取栈顶元素（top）</span></span><br><span class="line">stk[tt];</span><br></pre></td></tr></table></figure>

<h5 id="表达式求值（使用STL中的栈）"><a href="#表达式求值（使用STL中的栈）" class="headerlink" title="表达式求值（使用STL中的栈）"></a>表达式求值（使用STL中的栈）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; priority = &#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//取出两个操作数</span></span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    b = num.<span class="built_in">top</span>();</span><br><span class="line">    num.<span class="built_in">pop</span>();</span><br><span class="line">    a = num.<span class="built_in">top</span>();</span><br><span class="line">    num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">//取出一个运算符</span></span><br><span class="line">    <span class="type">char</span> c = op.<span class="built_in">top</span>();</span><br><span class="line">    op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) res = a+b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) res = a-b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>) res = a*b;</span><br><span class="line">    <span class="keyword">else</span> res = a/b;</span><br><span class="line">    num.<span class="built_in">push</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string exp;</span><br><span class="line">    cin&gt;&gt;exp;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 中序表达式转化为后序表达式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;exp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(exp[i]))&#123;</span><br><span class="line">            temp = temp*<span class="number">10</span> + exp[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&gt;=exp.<span class="built_in">size</span>() || !<span class="built_in">isdigit</span>(exp[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="comment">// 当输入的是操作数时候，直接输出到后序表达式序列中</span></span><br><span class="line">                num.<span class="built_in">push</span>(temp);</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(exp[i] == <span class="string">&#x27;(&#x27;</span> )&#123;</span><br><span class="line">            <span class="comment">// 把&#x27;(&#x27; 压入操作符栈</span></span><br><span class="line">            op.<span class="built_in">push</span>(exp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(exp[i] == <span class="string">&#x27;)&#x27;</span>)&#123; </span><br><span class="line">            <span class="comment">// 遇到右括号，先判断栈是否为空，若为空则数据出现错误</span></span><br><span class="line">            <span class="comment">// 依次弹出操作符栈中的操作符，接到后序表达式尾，直到遇到左括号</span></span><br><span class="line">            <span class="comment">// 若没有左括号，也出现错误</span></span><br><span class="line">            <span class="comment">// 本题目不考虑数据错误</span></span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// + - * / 运算符</span></span><br><span class="line">            <span class="comment">// 栈非空，且栈顶不为左括号，且栈顶运算符优先级&gt;=当前运算符（取=因为优先级相同时从左往右算），则</span></span><br><span class="line">            <span class="keyword">while</span>(!op.<span class="built_in">empty</span>() &amp;&amp; op.<span class="built_in">top</span>()!= <span class="string">&#x27;(&#x27;</span> &amp;&amp; priority[op.<span class="built_in">top</span>()] &gt;= priority[exp[i]]) <span class="built_in">eval</span>(); </span><br><span class="line">            <span class="comment">//把当前运算符压入操作符栈</span></span><br><span class="line">            op.<span class="built_in">push</span>(exp[i]);</span><br><span class="line">            <span class="comment">//这样做可以保证运算符栈前面的运算符优先级都&lt;新运算符（单调栈的思想？）</span></span><br><span class="line">            <span class="comment">//最后从后往前依次pop操作数和运算符进行运算就不会出错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>()) <span class="built_in">eval</span>(); <span class="comment">// 不考虑数据出错</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num.<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用数组模拟队列"><a href="#用数组模拟队列" class="headerlink" title="用数组模拟队列"></a>用数组模拟队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队尾插入，队头弹出</span></span><br><span class="line"><span class="type">int</span> q[N],hh,tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">q[++tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">hh++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="keyword">if</span>(hh &lt;= tt) 非空</span><br><span class="line"><span class="keyword">else</span> 空</span><br><span class="line">    </span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line">q[hh];</span><br></pre></td></tr></table></figure>

<h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>应用：求序列中每个数左边离它最近的小于它的数</p>
<p>如果栈中的数与将要插入栈的数存在逆序，则弹出前一个数，再把后一个数压入栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[tt]&gt;=x)&#123;</span><br><span class="line">            <span class="comment">//栈非空 且栈顶元素大于等于x</span></span><br><span class="line">            tt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tt) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,stk[tt]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        stk[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>应用：求滑动窗口中的最小值（最大值）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最小值：</span></span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经滑出窗口(队列中储存的是下标，因此队头不一定是窗口的左端)，如果队头还在窗口内就右移一格</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; i-k+<span class="number">1</span> &gt; q[hh]) hh++;<span class="comment">//i为窗口的终点，则i-k+1为窗口的起点</span></span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; <span class="comment">// 双端队列，在队尾进行删除操作。把尾部所有&gt;=a[i]的元素都删了，保证队列单调递增</span></span><br><span class="line">        </span><br><span class="line">        q[++t] = i;<span class="comment">//插入i(i有可能是最小值，所以先把i加入再输出最小值)</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);<span class="comment">// q[hh]即为当前窗口中最小的元素    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大值：</span></span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经滑出窗口(队列中储存的是下标，因此队头不一定是窗口的左端)</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; i-k+<span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; </span><br><span class="line">        </span><br><span class="line">        q[++t] = i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);/   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h1><p>字符串匹配</p>
<p>暴力解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s[M],p[N];</span><br><span class="line"><span class="comment">//s为待匹配的字符串，p为模式串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i+j<span class="number">-1</span>] != p[j])&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kmp算法：</p>
<p>next[i] &#x3D; j的含义：p[1…j] &#x3D; p[i-j+1…i]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">p[n],s[m]</span><br><span class="line"><span class="comment">//求next过程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ne[1]=0 因为如果第1个字符就不匹配了就只能i++</span></span><br><span class="line"><span class="comment">//因此求next从2开始</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    <span class="comment">//求next的过程实际上与匹配过程类似</span></span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配过程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>; i&lt;=m; i++)&#123;    </span><br><span class="line">	<span class="comment">//while(j)说明j前面的字符都是匹配的，s[i] != p[j+1]是检验s中的i与p中的j+1是否匹配。</span></span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>])&#123; <span class="comment">//s[i]与p[j+1]不匹配</span></span><br><span class="line">        j = ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++; <span class="comment">//s[i]与p[j+1]已经匹配了，则可以匹配下一个字符了</span></span><br><span class="line">    <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">        <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这里要看s的下标是从0开始还是从1开始，若从0开始则输出i-n</span></span><br><span class="line">        j = ne[j];<span class="comment">//s中可能包含多个p，因此一次匹配成功后应再次后移模式串，继续匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Trie树（字典树、前缀树）"><a href="#Trie树（字典树、前缀树）" class="headerlink" title="Trie树（字典树、前缀树）"></a>Trie树（字典树、前缀树）</h1><p>高效地存储和查找字符串集合的数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], <span class="comment">//所有结点的子节点</span></span><br><span class="line">	cnt[N], <span class="comment">//以当前结点结尾的单词有多少个</span></span><br><span class="line">	idx; <span class="comment">//分配的下标。下标是0的点，既是根节点，又是空结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; str[i]; i++)&#123; <span class="comment">//字符串结尾是\0,因此可以直接判断str[i]</span></span><br><span class="line">        <span class="type">int</span> u = str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束后p所在的位置就是单词结尾</span></span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, M = <span class="number">31</span>*N; <span class="comment">// M表示所有数字二进制位的最大总长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>], idx=<span class="number">0</span>, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">//取x的第i位</span></span><br><span class="line">        <span class="type">int</span> u = x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cnt[p]++;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="type">int</span> u = x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])&#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = res*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = res*<span class="number">2</span>+<span class="number">0</span>; <span class="comment">//移位运算的优先级比+-低</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="comment">//搜索所有的a[i]</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">search</span>(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>作用：</p>
<ol>
<li>将两个集合合并</li>
<li>询问两个元素是否在同一个集合中</li>
</ol>
<p>近乎O(1)</p>
<p>原理：</p>
<p>每一个集合用一棵树来表示，树根的编号就算这个集合的编号，每一个结点存储它的父节点，p[x]表示x的父节点。</p>
<p>如何判断树根：p[x]&#x3D;x</p>
<p>如何求x的集合编号：while(p[x] !&#x3D; x) x &#x3D; p[x];</p>
<p>如何合并两个集合：p[x] &#x3D; py;</p>
<h5 id="优化：路径压缩"><a href="#优化：路径压缩" class="headerlink" title="优化：路径压缩"></a>优化：路径压缩</h5><p>当x找到根节点后，把路径上的所有点的父节点都指向根节点</p>
<p>（优化2：按秩合并）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m; <span class="comment">// n:点的数量 m:操作数量</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> size[N]; <span class="comment">//**获取集合的元素数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回x所在集合的编号即祖宗结点（包含路径压缩）</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//一定要记得初始化！</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;p[i] = i; size[i] = <span class="number">1</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">3</span>]; <span class="comment">//scanf读字符串会自动忽略空格和回车，不像读入单个字符容易出问题</span></span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">continue</span>;<span class="comment">//如果a和b已经在一个集合中，则不需合并（不需要计算size的时候其实不用管这个情况，但如果要计算size的话需要考虑如果原来就在同一个集合中size就不应该改变</span></span><br><span class="line">            size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)]; <span class="comment">//**</span></span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">//合并</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//**问a所在的集合的元素个数时</span></span><br><span class="line">        <span class="comment">//**size[find(a)]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="返回集合中元素的个数："><a href="#返回集合中元素的个数：" class="headerlink" title="返回集合中元素的个数："></a>返回集合中元素的个数：</h5><p>维护一个size[N]数组（只有根结点的size有意义）</p>
<p>合并时，先判断a和b是否来自同一个集合，即find(a)是否等于find(b)。若来自不同集合，则<code>size[find(b)]+= size[find(a)]</code>；若来自同一集合，则size不变</p>
<p>获取size时直接返回size[find(a)]</p>
<h5 id="例：食物链"><a href="#例：食物链" class="headerlink" title="例：食物链"></a>例：食物链</h5><h6 id="做法1：将数组划分成3个域"><a href="#做法1：将数组划分成3个域" class="headerlink" title="做法1：将数组划分成3个域"></a>做法1：将数组划分成3个域</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200000</span>;</span><br><span class="line"><span class="type">int</span> p[N],idx;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==p[x]) </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p[x]=<span class="built_in">get</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="built_in">get</span>(x)]=<span class="built_in">get</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*n;i++) <span class="comment">//因为有3个域：同类、天敌、捕食，因此开了三倍空间</span></span><br><span class="line">        p[i]=i;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// x是同类域. x+n是捕食域. x+n+n是天敌域</span></span><br><span class="line">    <span class="type">int</span> d,x,y;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;d,&amp;x,&amp;y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x&gt;n || y&gt;n) count++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//x y是同类</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">get</span>(x) == <span class="built_in">get</span>(y+n) || <span class="built_in">get</span>(x) == <span class="built_in">get</span>(y+n+n)) count++; <span class="comment">//x是y的捕食中的动物,或者x是y天敌中的动物</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">merge</span>(x,y);</span><br><span class="line">                <span class="built_in">merge</span>(x+n,y+n);</span><br><span class="line">                <span class="built_in">merge</span>(x+n+n,y+n+n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//x 捕食 y</span></span><br><span class="line">            <span class="keyword">if</span>(x==y || <span class="built_in">get</span>(x)==<span class="built_in">get</span>(y) || <span class="built_in">get</span>(x) == <span class="built_in">get</span>(y+n)) count++; <span class="comment">//x与y相同，或x和y是同类，或x在y的捕食域中</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">merge</span>(x,y+n+n); <span class="comment">// x的同类域=y的天敌域</span></span><br><span class="line">                <span class="built_in">merge</span>(x+n,y); <span class="comment">// x的捕食域=y的同类域</span></span><br><span class="line">                <span class="built_in">merge</span>(x+n+n,y+n); <span class="comment">// x的天敌域=y的捕食域</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="做法2：带权并查集"><a href="#做法2：带权并查集" class="headerlink" title="做法2：带权并查集"></a>做法2：带权并查集</h6><p>每个点维护与父节点的距离（以距离表示关系，0为同类，1为吃，2为被吃）。路径压缩时，把路径上的距离加起来作为每个点到根节点的距离，对3取模，余0为同类，余1为吃，余2为被吃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> p[N],d[N],idx;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">get</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">        p[i]=i; <span class="comment">// d[i]=0 不需要初始化</span></span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> t,x,y;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;x,&amp;y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x&gt;n || y&gt;n) count++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">get</span>(x), py = <span class="built_in">get</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// X和y是同类</span></span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x]-d[y])%<span class="number">3</span>) count++; <span class="comment">// x和y在同一个集合里，x、y的关系已知</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)&#123;</span><br><span class="line">                    <span class="comment">// x和y不在同一个集合里，x与y的关系未知（则把这句话当成真话来确定px与py的距离）</span></span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y]-d[x]; <span class="comment">//这里不需要保证&gt;0?</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x]-d[y]<span class="number">-1</span>)%<span class="number">3</span>) count++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)&#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y]+<span class="number">1</span>-d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>手写堆：</p>
<ol>
<li>插入一个数</li>
<li>求集合中的最小值</li>
<li>删除最小值</li>
<li>删除任意一个元素*</li>
<li>修改任意一个元素*</li>
</ol>
<p>带*的是stl里的堆没有的功能</p>
<h5 id="堆的结构：完全二叉树（分为大根堆和小根堆）"><a href="#堆的结构：完全二叉树（分为大根堆和小根堆）" class="headerlink" title="堆的结构：完全二叉树（分为大根堆和小根堆）"></a>堆的结构：完全二叉树（分为大根堆和小根堆）</h5><p>小根堆：每个点都小于等于左右儿子 &#x3D;&gt; 根节点是最小的点</p>
<h5 id="堆的存储方式：一维数组"><a href="#堆的存储方式：一维数组" class="headerlink" title="堆的存储方式：一维数组"></a>堆的存储方式：一维数组</h5><p>下标为1的点：根节点</p>
<p>x的左儿子：2x</p>
<p>x的右儿子：2x+1</p>
<h5 id="两个基本操作：down-X-和up-x"><a href="#两个基本操作：down-X-和up-x" class="headerlink" title="两个基本操作：down(X)和up(x)"></a>两个基本操作：down(X)和up(x)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t=u;</span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span> &lt;= size &amp;&amp; h[u*<span class="number">2</span>] &lt; h[t]) t=u*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span> &lt;= size &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>] &lt; h[t]) t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 此时t存的是u和u的左右儿子里面的最小值的位置</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u],h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>]&gt;h[u])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u/<span class="number">2</span>],h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手写堆：</p>
<ol>
<li>插入一个数</li>
<li>求集合当中的最小值</li>
<li>删除最小值</li>
<li>删除任意一个元素</li>
<li>修改任意一个元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组heap[]表示堆，size表示堆当前的大小</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">heap[++size]=x; <span class="built_in">up</span>(size); <span class="comment">//在最后一个元素插入，然后上移</span></span><br><span class="line"><span class="comment">// 集合中的最小值</span></span><br><span class="line">heap[<span class="number">1</span>]; <span class="comment">//小根堆 根节点最小</span></span><br><span class="line"><span class="comment">// 删除最小值</span></span><br><span class="line">heap[<span class="number">1</span>]=heap[size--]; <span class="built_in">down</span>(<span class="number">1</span>); <span class="comment">//用堆的最后一个元素覆盖第一个点</span></span><br><span class="line"><span class="comment">// 删除任意一个点k</span></span><br><span class="line">heap[k]=heap[size]; size--; <span class="built_in">down</span>(k); <span class="built_in">up</span>(k);</span><br><span class="line"><span class="comment">// 修改任意一个元素</span></span><br><span class="line">heap[k]=x; <span class="built_in">down</span>(k); <span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>建立小根堆-&gt;取出最小值-&gt;删除最小值-&gt;重新建立小根堆…</p>
<p>实际上只用到了2和3操作</p>
<h5 id="求前m小的数"><a href="#求前m小的数" class="headerlink" title="求前m小的数"></a>求前m小的数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N],size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    size = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建堆：从n/2开始对上方的元素进行down操作</span></span><br><span class="line">	<span class="comment">// 可在O(n)内建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>; i; i--) <span class="built_in">down</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,h[i]); <span class="comment">//输出堆顶</span></span><br><span class="line">        h[<span class="number">1</span>] = h[size];</span><br><span class="line">        size--; <span class="comment">//删除堆顶</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>); <span class="comment">//重新调整为堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],ph[N],hp[N],size;</span><br><span class="line"><span class="comment">// ph[k]:第k个插入的数的下标</span></span><br><span class="line"><span class="comment">// hp[k]:堆里的某个点是第几个插入的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//交换a和b位置的点</span></span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span> &lt;= size &amp;&amp; h[u*<span class="number">2</span>] &lt; h[t]) t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span> &lt;= size &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>] &lt; h[t]) t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)&#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>]&gt;h[t])&#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>,u);</span><br><span class="line">        u/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m=<span class="number">0</span>; <span class="comment">//第几个插入的数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;I&quot;</span>))&#123; <span class="comment">//插入</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            size++;</span><br><span class="line">            m++;</span><br><span class="line">            ph[m] = size; <span class="comment">//当前插入的数位置为size</span></span><br><span class="line">            hp[size] = m;</span><br><span class="line">            h[size] = x;</span><br><span class="line">            <span class="built_in">up</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,h[<span class="number">1</span>]); <span class="comment">//输出最小值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;DM&quot;</span>)) <span class="comment">//删除最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,size);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;D&quot;</span>))&#123; <span class="comment">//删除第k个插入的数</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">            k = ph[k]; <span class="comment">//第k个插入的数的位置</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k,size);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//修改第k个插入的数</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h4 id="存储结构（根据冲突的处理方式分）"><a href="#存储结构（根据冲突的处理方式分）" class="headerlink" title="存储结构（根据冲突的处理方式分）"></a>存储结构（根据冲突的处理方式分）</h4><ol>
<li>开放寻址法</li>
<li>拉链法</li>
</ol>
<p>常用的哈希函数：取模 如：h(x)&#x3D;x mod 10^5^</p>
<p>一般模的数要取成质数，并且离2的整次幂尽可能远</p>
<h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p>映射后每一个位置存一个链表</p>
<p>查找：找到h(x)对应的链表，遍历链表看x在不在里面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x%N + N) % N; <span class="comment">//c++中负数取模等于模的负数，加上N变为正数，而正数+N会超过N，因此再次取模</span></span><br><span class="line">    e[idx] = x, ne[idx] = h[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x%N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[k]; i!=<span class="number">-1</span>; i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">//先把散列表的每个槽清空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;i&#x27;</span>) <span class="built_in">insert</span>(X);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>; </span><br><span class="line"><span class="comment">//memset(h,0x3f, sizeof h): memset按字节赋值，一个int型数据是四个字节因此这里只写一个字节的值</span></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果x在哈希表中存在，则返回x的位置，否则返回x应该存储的位置</span></span><br><span class="line">    <span class="type">int</span> k = (x%N + N)% N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)&#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k==N) k=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><p>字符串前缀哈希法：把字符串看作一个p进制数,h[0]&#x3D;0,h[i]为前i个字母组成的字符串的hash值</p>
<p>p&#x3D;131或13331</p>
<p>q&#x3D;2^64^ 一般用usigned long long来存储前缀和，如果溢出就相当于模2^64^</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, P=<span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N],p[N]; <span class="comment">//p[N]为存储p的乘方的辅助数组</span></span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n,&amp;m,str+<span class="number">1</span>); <span class="comment">//从str[1]开始存储字符串</span></span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 把P进制转化为10进制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>]*P; <span class="comment">// p[i]等于p的i次方</span></span><br><span class="line">        h[i] = h[i<span class="number">-1</span>]*P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;l2,&amp;r1,&amp;r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1,r1)==<span class="built_in">get</span>(l2,r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p><a target="_blank" rel="noopener" href="http://www.cplusplus.com/">www.cplusplus.com</a> 可以查看reference</p>
<h4 id="vector-变长数组"><a href="#vector-变长数组" class="headerlink" title="vector 变长数组"></a>vector 变长数组</h4><p>头文件：<code>&lt;vector&gt;</code></p>
<p>倍增的思想：每次空间不够就把长度*2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(长度,[默认值])</span></span>;</span><br><span class="line"><span class="comment">//返回元素个数 所有容器都有</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//返回是否是空的 O(1) 所有容器都有</span></span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//返回第一个数/最后一个数</span></span><br><span class="line">a.<span class="built_in">front</span>(),a.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//在末尾添加/删除一个数</span></span><br><span class="line">a.push_Back,a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>();</span><br><span class="line"><span class="comment">//可以比较大小（按字典序）</span></span><br><span class="line">a&lt;b</span><br></pre></td></tr></table></figure>

<h4 id="pair-二元组"><a href="#pair-二元组" class="headerlink" title="pair 二元组"></a>pair 二元组</h4><p>头文件：<code>&lt;utility&gt;</code> 但可以不用包含</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">pair&lt;<span class="type">int</span>,string&gt; p; <span class="comment">//前后类型任意</span></span><br><span class="line"><span class="comment">//两种初始化方式</span></span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="number">10</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">p = &#123;<span class="number">20</span>,<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">p.first, p.second;</span><br><span class="line"><span class="comment">//支持比较运算，以first为第一关键字，以second为第二关键字</span></span><br></pre></td></tr></table></figure>

<h4 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h4><p>支持size(), empty(), clear()。length()和size()一样</p>
<p>substr() 求子串</p>
<p><code>a.substr(起始下标, 子串长度);</code></p>
<p>若长度超过了字符串的长度（或没有给出第二个参数），则输出到字符串结尾为止</p>
<p>c_str()</p>
<p><code>a.c_str()</code>返回存储字符串a的字符数组的起始地址</p>
<p>如：printf无法直接输出string类型，可以用<code>printf(&quot;%s\n&quot;, a.c_str());</code></p>
<h4 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h4><p>支持size()和empty()，但没有clear()，想要清空可以重新构造一个</p>
<p>push() 向队尾插入元素</p>
<p>front() 返回队头元素</p>
<p>back() 返回队尾元素</p>
<p>pop() 弹出队头元素</p>
<h4 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue 优先队列"></a>priority_queue 优先队列</h4><p>实际是堆，默认是大根堆</p>
<p>没有clear()</p>
<h5 id="如何变为小根堆？"><a href="#如何变为小根堆？" class="headerlink" title="如何变为小根堆？"></a>如何变为小根堆？</h5><ol>
<li>插入的时候，插入元素的负值（取出的时候记得再加一个负号）</li>
<li><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap</code>定义后就是小根堆</li>
</ol>
<p>push() 插入一个元素</p>
<p>top() 返回堆顶</p>
<p>pop() 将堆顶弹出</p>
<h4 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h4><p>没有clear()</p>
<p>push() 向栈顶插入元素</p>
<p>top() 返回栈顶元素</p>
<p>pop() 弹出栈顶元素</p>
<h4 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque 双端队列"></a>deque 双端队列</h4><p>有size()和empty()，也有clear()</p>
<p>front()</p>
<p>back()</p>
<p>push_back()&#x2F;pop_back()</p>
<p>push_front()&#x2F;pop_front()</p>
<p>begin()&#x2F;end()</p>
<p>[] 可以随机存取</p>
<p>方法很多，但速度很慢，不常用。</p>
<h4 id="set-map-multiset-multimap"><a href="#set-map-multiset-multimap" class="headerlink" title="set,map,multiset,multimap"></a>set,map,multiset,multimap</h4><p>头文件: <code>&lt;set&gt;</code></p>
<p>基于平衡二叉树（红黑树），动态维护有序序列</p>
<p>支持size(), empty(), clear()</p>
<p>begin(),end() 迭代器可以++、– 时间复杂度为O(logn)</p>
<h5 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h5><p>区别：set里不能有重复元素，而multiset可以</p>
<p>insert() 插入一个数</p>
<p>find() 查找一个数。如果不存在，返回end()</p>
<p>count() 返回某一个数的个数（set中最多1个）</p>
<p>erase()</p>
<ol>
<li>输入是一个数x，则删除所有x。 O(k+log(n))</li>
<li>输入是一个迭代器，则删除这个迭代器</li>
</ol>
<p>lower_bound() 返回&gt;&#x3D;x的最小的数。如果不存在，返回end()</p>
<p>upper_bound() 返回&gt;x的最小的数。如果不存在，返回end()</p>
<h5 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h5><p>insert() 插入一个pair</p>
<p>erase() 输入的参数可以是一个pair或一个迭代器</p>
<p>find()</p>
<p>[] 可以随机存取，时间复杂度为O(logn)</p>
<p>lower_bound()&#x2F;upper_bound() </p>
<h4 id="unordered-set-unordered-map-unordered-multiset-unordered-multimap"><a href="#unordered-set-unordered-map-unordered-multiset-unordered-multimap" class="headerlink" title="unordered_set, unordered_map, unordered_multiset, unordered_multimap"></a>unordered_set, unordered_map, unordered_multiset, unordered_multimap</h4><p>基于哈希表</p>
<p>和上面的类似，增删改查的时间复杂度为O(1)，但不支持lower_bound()&#x2F;upper_bound()</p>
<h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><p>压位</p>
<p>c++中一个bool类型的变量占<strong>一个字节</strong>，但实际上一个bool变量用一位(0或1就能表示)</p>
<p>因此 开1024大小的bool数组 &#x3D; 开128位的bitset，可以省8倍空间</p>
<p>定义：<br><code>bitset&lt;10000&gt; s; //&lt;&gt;中写的是长度</code><br>支持的运算：<br><code>~ 取反, &amp; 与, | 或, ^ 异或</code></p>
<p><code>&gt;&gt;, &lt;&lt;</code>,<br><code>==, !=</code><br><code>[]</code></p>
<p>count() 返回有多少个1</p>
<p>any() 返回是否至少有一个1</p>
<p>none() 判断是否全为0</p>
<p>set() 把所有位置为1</p>
<p>set(k,v) 将第k位变成v</p>
<p>reset() 把所有位变成0</p>
<p>flip() 把所有位取反，等价于~</p>
<p>flip(k) 把第k位取反</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/28/hello-world/">Hello World</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-28</time><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{%raw%}$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">${%endraw%} hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{%raw%}$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">${%endraw%} hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By re-burn</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>